// =============================================================================
// INPUT STAGE BLOCK - Distortion Plugin
// =============================================================================
// Procesamiento de entrada con filtros HPF/LPF, Input Trim y Tilt Filter
//
// ENTRADAS:
// - in1: Audio L
// - in2: Audio R
//
// SALIDAS:
// - out1: L procesado (filtrado + trim + tilt)
// - out2: R procesado (filtrado + trim + tilt)
// =============================================================================

// PARÁMETROS
// Filtros HPF/LPF
Param j_HPF(20, min=20, default=20, max=20000);       // Input HPF frequency (Hz)
Param k_LPF(20000, min=20, default=20000, max=20000); // Input LPF frequency (Hz)
Param l_SC(0, min=0, default=0, max=1);               // Input filter enable

// Input Trim y Tilt
Param k_INPUT(0, min=-12, default=0, max=12);         // Input trim gain (dB)
Param i_TILT(0, min=-6, default=0, max=6);            // Tilt filter (dB)

// HISTORIALES
// Smoothing principal
History hInput(0);
History hTilt(0);

// Historiales para filtros de 1 polo (más simples)
History hpfL_z1(0);
History hpfR_z1(0);
History lpfL_z1(0);
History lpfR_z1(0);

// Historiales para smoothing de filtros
History hpfFreqHistory(0);
History lpfFreqHistory(0);
History scEnableHistory(0);

// Historiales para filtros Tilt
History tiltL1(0), tiltL2(0), tiltL3(0), tiltL4(0);
History tiltR1(0), tiltR2(0), tiltR3(0), tiltR4(0);

// CONSTANTES
smoothFactor = 0.999;

// =============================================================================
// PROCESAMIENTO
// =============================================================================

// Entrada
lIn = in1;
rIn = in2;

// Smoothing de parámetros principales
hInput = hInput * smoothFactor + k_INPUT * (1 - smoothFactor);
inputTrimDb = hInput;
inputTrimLinear = dbtoa(inputTrimDb);

hTilt = hTilt * smoothFactor + i_TILT * (1 - smoothFactor);
tiltDb = hTilt;

// Suavizado de parámetros de filtros
smoothHpfFreq = (hpfFreqHistory * smoothFactor) + (j_HPF * (1 - smoothFactor));
hpfFreqHistory = fixdenorm(smoothHpfFreq);

smoothLpfFreq = (lpfFreqHistory * smoothFactor) + (k_LPF * (1 - smoothFactor));
lpfFreqHistory = fixdenorm(smoothLpfFreq);

smoothScEnable = (scEnableHistory * smoothFactor) + (l_SC * (1 - smoothFactor));
scEnableHistory = fixdenorm(smoothScEnable);

// -----------------------------------------------------------------------------
// INPUT TRIM
// -----------------------------------------------------------------------------
lTrimmed = lIn * inputTrimLinear;
rTrimmed = rIn * inputTrimLinear;

// -----------------------------------------------------------------------------
// FILTROS DE 1 POLO SIMPLES (6 dB/oct)
// -----------------------------------------------------------------------------
// Estos filtros son más simples y siempre funcionan

// Coeficiente HPF (1 polo)
hpf_freq = clip(smoothHpfFreq, 20, 20000);
hpf_coeff = exp(-2 * pi * hpf_freq / samplerate);

// Procesamiento HPF
hpfL_out = lTrimmed - hpfL_z1;
hpfL_z1 = lTrimmed - (hpfL_out * hpf_coeff);

hpfR_out = rTrimmed - hpfR_z1;
hpfR_z1 = rTrimmed - (hpfR_out * hpf_coeff);

// Coeficiente LPF (1 polo)
lpf_freq = clip(smoothLpfFreq, 20, 20000);
lpf_coeff = 2 * pi * lpf_freq / samplerate;
lpf_coeff = clip(lpf_coeff, 0, 1);

// Procesamiento LPF (aplicado a la salida del HPF)
lpfL_z1 = lpfL_z1 + lpf_coeff * (hpfL_out - lpfL_z1);
lpfR_z1 = lpfR_z1 + lpf_coeff * (hpfR_out - lpfR_z1);

// Señal filtrada
filteredL = lpfL_z1;
filteredR = lpfR_z1;

// Mezclar señal filtrada con original según filter enable
lFiltered = mix(lTrimmed, filteredL, smoothScEnable);
rFiltered = mix(rTrimmed, filteredR, smoothScEnable);

// -----------------------------------------------------------------------------
// FILTRO TILT PRE-DISTORSIÓN
// -----------------------------------------------------------------------------
fc = 800.0;
q = 0.7071;

// Cálculo de coeficientes para Tilt (invertido para UI intuitiva)
tiltGain = dbtoa(-tiltDb);
omega = (fc * twopi) / samplerate;
sn = sin(omega);
cs = cos(omega);
A = sqrt(tiltGain);
beta = sqrt((A * A + 1) / q - (A - 1) * (A - 1));

// Coeficientes Low Shelf
b0Ls = 1 / ((A + 1) + (A - 1) * cs + beta * sn);
a0Ls = A * ((A + 1) - (A - 1) * cs + beta * sn) * b0Ls;
a1Ls = 2 * A * ((A - 1) - (A + 1) * cs) * b0Ls;
a2Ls = A * ((A + 1) - (A - 1) * cs - beta * sn) * b0Ls;
b1Ls = -2 * ((A - 1) + (A + 1) * cs) * b0Ls;
b2Ls = ((A + 1) + (A - 1) * cs - beta * sn) * b0Ls;

// Aplicar Low Shelf
lLs = a0Ls * lFiltered + a1Ls * tiltL2 + a2Ls * tiltL1 - b1Ls * tiltL4 - b2Ls * tiltL3;
tiltL1 = tiltL2;
tiltL2 = lFiltered;
tiltL3 = tiltL4;
tiltL4 = lLs;

rLs = a0Ls * rFiltered + a1Ls * tiltR2 + a2Ls * tiltR1 - b1Ls * tiltR4 - b2Ls * tiltR3;
tiltR1 = tiltR2;
tiltR2 = rFiltered;
tiltR3 = tiltR4;
tiltR4 = rLs;

// Coeficientes High Shelf
aInv = sqrt(1/tiltGain);
betaHs = sqrt((aInv * aInv + 1) / q - (aInv - 1) * (aInv - 1));

b0Hs = 1 / ((aInv + 1) - (aInv - 1) * cs + betaHs * sn);
a0Hs = aInv * ((aInv + 1) + (aInv - 1) * cs + betaHs * sn) * b0Hs;
a1Hs = -2 * aInv * ((aInv - 1) + (aInv + 1) * cs) * b0Hs;
a2Hs = aInv * ((aInv + 1) + (aInv - 1) * cs - betaHs * sn) * b0Hs;
b1Hs = 2 * ((aInv - 1) - (aInv + 1) * cs) * b0Hs;
b2Hs = ((aInv + 1) - (aInv - 1) * cs - betaHs * sn) * b0Hs;

lTilt = a0Hs * lLs + a1Hs * tiltL2 + a2Hs * tiltL1 - b1Hs * tiltL4 - b2Hs * tiltL3;
rTilt = a0Hs * rLs + a1Hs * tiltR2 + a2Hs * tiltR1 - b1Hs * tiltR4 - b2Hs * tiltR3;

// -----------------------------------------------------------------------------
// SALIDAS
// -----------------------------------------------------------------------------
out1 = lTilt;      // L procesado completo (filtrado + trim + tilt)
out2 = rTilt;      // R procesado completo
