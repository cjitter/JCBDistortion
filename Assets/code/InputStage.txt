// =============================================================================
// INPUT STAGE BLOCK - Distortion Plugin
// =============================================================================
// Procesamiento de entrada con filtros HPF/LPF, Input Trim y Tilt Filter
//
// ENTRADAS:
// - in1: Audio L
// - in2: Audio R
//
// SALIDAS:
// - out1: L procesado (filtrado + trim + tilt)
// - out2: R procesado (filtrado + trim + tilt)  
// - out3: L post-trim (para medidores, sin tilt)
// - out4: R post-trim (para medidores, sin tilt)
// =============================================================================

// PARÁMETROS
// Filtros HPF/LPF
Param j_HPF(20, min=20, default=20, max=20000);       // Input HPF frequency (Hz)
Param j_HPFORDER(0, min=0, default=0, max=1);         // HPF order (0=12dB/oct, 1=24dB/oct)
Param k_LPF(20000, min=20, default=20000, max=20000); // Input LPF frequency (Hz)
Param k_LPFORDER(0, min=0, default=0, max=1);         // LPF order (0=12dB/oct, 1=24dB/oct)
Param l_SC(0, min=0, default=0, max=1);               // Input filter enable

// Input Trim y Tilt
Param k_INPUT(0, min=-12, default=0, max=12);         // Input trim gain (dB)
Param i_TILT(0, min=-6, default=0, max=6);            // Tilt filter (dB)

// HISTORIALES
// Smoothing principal
History hInput(0);
History hTilt(0);

// Historiales para filtros HPF/LPF - Canal L
History lpfL1(0), lpfL2(0), lpfL3(0), lpfL4(0);
History lpfL5(0), lpfL6(0), lpfL7(0), lpfL8(0);
History hpfL1(0), hpfL2(0), hpfL3(0), hpfL4(0);
History hpfL5(0), hpfL6(0), hpfL7(0), hpfL8(0);

// Historiales para filtros HPF/LPF - Canal R
History lpfR1(0), lpfR2(0), lpfR3(0), lpfR4(0);
History lpfR5(0), lpfR6(0), lpfR7(0), lpfR8(0);
History hpfR1(0), hpfR2(0), hpfR3(0), hpfR4(0);
History hpfR5(0), hpfR6(0), hpfR7(0), hpfR8(0);

// Historiales para smoothing de filtros
History hpfFreqHistory(0);
History lpfFreqHistory(0);
History scEnableHistory(0);
History hpfOrderHistory(0);
History lpfOrderHistory(0);

// Historiales para filtros Tilt
History tiltL1(0), tiltL2(0), tiltL3(0), tiltL4(0);
History tiltR1(0), tiltR2(0), tiltR3(0), tiltR4(0);

// CONSTANTES
smoothFactor = 0.999;
BUTTERWORTH_Q = 1.0;  // Q = 1 para respuesta plana sin resonancia

// =============================================================================
// PROCESAMIENTO
// =============================================================================

// Entrada
lIn = in1;
rIn = in2;

// Smoothing de parámetros principales
hInput = hInput * smoothFactor + k_INPUT * (1 - smoothFactor);
inputTrimDb = hInput;
inputTrimLinear = dbtoa(inputTrimDb);

hTilt = hTilt * smoothFactor + i_TILT * (1 - smoothFactor);
tiltDb = hTilt;

// Suavizado de parámetros de filtros
smoothHpfFreq = (hpfFreqHistory * smoothFactor) + (j_HPF * (1 - smoothFactor));
hpfFreqHistory = fixdenorm(smoothHpfFreq);

smoothLpfFreq = (lpfFreqHistory * smoothFactor) + (k_LPF * (1 - smoothFactor));
lpfFreqHistory = fixdenorm(smoothLpfFreq);

smoothScEnable = (scEnableHistory * smoothFactor) + (l_SC * (1 - smoothFactor));
scEnableHistory = fixdenorm(smoothScEnable);

smoothHpfOrder = (hpfOrderHistory * smoothFactor) + (j_HPFORDER * (1 - smoothFactor));
hpfOrderHistory = fixdenorm(smoothHpfOrder);

smoothLpfOrder = (lpfOrderHistory * smoothFactor) + (k_LPFORDER * (1 - smoothFactor));
lpfOrderHistory = fixdenorm(smoothLpfOrder);

// Selección discreta de orden
hpfOrderDiscrete = smoothHpfOrder < 0.5 ? 0 : 1;
lpfOrderDiscrete = smoothLpfOrder < 0.5 ? 0 : 1;

// -----------------------------------------------------------------------------
// FILTROS HPF/LPF DE ENTRADA (ESTÉREO)
// -----------------------------------------------------------------------------

// Coeficientes LPF Butterworth de 2º orden
omega = ((smoothLpfFreq * twopi)) / samplerate;
sn = sin(omega);
cs = cos(omega);
one_over_Q = 1 / BUTTERWORTH_Q;
alpha = ((sn * 0.5)) * one_over_Q;
b0 = 1 / ((1 + alpha));
a2 = ((((1 - cs)) * 0.5)) * b0;
a1 = ((1 - cs)) * b0;
b1 = ((-2 * cs)) * b0;
b2 = ((1 - alpha)) * b0;

lpfCoeffA2 = a2;
lpfCoeffA1 = a1;
lpfCoeffA0 = a2;
lpfCoeffB1 = b1;
lpfCoeffB2 = b2;

// Coeficientes HPF Butterworth de 2º orden
omega_hpf = ((smoothHpfFreq * twopi)) / samplerate;
sn_hpf = sin(omega_hpf);
cs_hpf = cos(omega_hpf);
alpha_hpf = ((sn_hpf * 0.5)) / BUTTERWORTH_Q;
b0_hpf = 1 / ((1 + alpha_hpf));
a_hpf = ((((1 + cs_hpf)) * 0.5)) * b0_hpf;
a_neg_hpf = (-(1 + cs_hpf)) * b0_hpf;
b1_hpf = ((-2 * cs_hpf)) * b0_hpf;
b2_hpf = ((1 - alpha_hpf)) * b0_hpf;

hpfCoeffA2 = a_hpf;
hpfCoeffA1 = a_neg_hpf;
hpfCoeffA0 = a_hpf;
hpfCoeffB1 = b1_hpf;
hpfCoeffB2 = b2_hpf;

// === PROCESAMIENTO LPF ESTÉREO ===
// Canal izquierdo - Primera etapa LPF (12 dB/oct)
lpfInputL = lIn * lpfCoeffA2;
lpfFromHistoryL1 = lpfL3 * lpfCoeffA1;
lpfFromHistoryL2 = lpfL1 * lpfCoeffA0;
lpfFeedbackL1 = lpfL2 * lpfCoeffB2;
lpfFeedbackL2 = lpfL4 * lpfCoeffB1;
lpfFilteredL = ((((lpfFromHistoryL2 + lpfFromHistoryL1)) + lpfInputL)) - ((lpfFeedbackL2 + lpfFeedbackL1));

lpfL1 = fixdenorm(lpfL3);
lpfL2 = fixdenorm(lpfL4);
lpfL3 = fixdenorm(lIn);
lpfL4 = fixdenorm(lpfFilteredL);

// Canal izquierdo - Segunda etapa LPF (para 24 dB/oct)
lpfStage2InputL = lpfFilteredL * lpfCoeffA2;
lpfStage2FromHistoryL1 = lpfL7 * lpfCoeffA1;
lpfStage2FromHistoryL2 = lpfL5 * lpfCoeffA0;
lpfStage2FeedbackL1 = lpfL6 * lpfCoeffB2;
lpfStage2FeedbackL2 = lpfL8 * lpfCoeffB1;
lpfStage2FilteredL = ((((lpfStage2FromHistoryL2 + lpfStage2FromHistoryL1)) + lpfStage2InputL)) - ((lpfStage2FeedbackL2 + lpfStage2FeedbackL1));

lpfL5 = fixdenorm(lpfL7);
lpfL6 = fixdenorm(lpfL8);
lpfL7 = fixdenorm(lpfFilteredL);
lpfL8 = fixdenorm(lpfStage2FilteredL);

lpfFinalL = lpfOrderDiscrete == 0 ? lpfFilteredL : lpfStage2FilteredL;

// Canal derecho - Primera etapa LPF (12 dB/oct)
lpfInputR = rIn * lpfCoeffA2;
lpfFromHistoryR1 = lpfR3 * lpfCoeffA1;
lpfFromHistoryR2 = lpfR1 * lpfCoeffA0;
lpfFeedbackR1 = lpfR2 * lpfCoeffB2;
lpfFeedbackR2 = lpfR4 * lpfCoeffB1;
lpfFilteredR = ((((lpfFromHistoryR2 + lpfFromHistoryR1)) + lpfInputR)) - ((lpfFeedbackR2 + lpfFeedbackR1));

lpfR1 = fixdenorm(lpfR3);
lpfR2 = fixdenorm(lpfR4);
lpfR3 = fixdenorm(rIn);
lpfR4 = fixdenorm(lpfFilteredR);

// Canal derecho - Segunda etapa LPF (para 24 dB/oct)
lpfStage2InputR = lpfFilteredR * lpfCoeffA2;
lpfStage2FromHistoryR1 = lpfR7 * lpfCoeffA1;
lpfStage2FromHistoryR2 = lpfR5 * lpfCoeffA0;
lpfStage2FeedbackR1 = lpfR6 * lpfCoeffB2;
lpfStage2FeedbackR2 = lpfR8 * lpfCoeffB1;
lpfStage2FilteredR = ((((lpfStage2FromHistoryR2 + lpfStage2FromHistoryR1)) + lpfStage2InputR)) - ((lpfStage2FeedbackR2 + lpfStage2FeedbackR1));

lpfR5 = fixdenorm(lpfR7);
lpfR6 = fixdenorm(lpfR8);
lpfR7 = fixdenorm(lpfFilteredR);
lpfR8 = fixdenorm(lpfStage2FilteredR);

lpfFinalR = lpfOrderDiscrete == 0 ? lpfFilteredR : lpfStage2FilteredR;

// Mezclar señal directa con LPF según filter enable
lpfMixedL = mix(lIn, lpfFinalL, smoothScEnable);
lpfMixedR = mix(rIn, lpfFinalR, smoothScEnable);

// === PROCESAMIENTO HPF ESTÉREO ===
// Canal izquierdo - Primera etapa HPF (12 dB/oct)
hpfInputL = lpfMixedL * hpfCoeffA2;
hpfFromHistoryL1 = hpfL3 * hpfCoeffA1;
hpfFromHistoryL2 = hpfL2 * hpfCoeffA0;
hpfFeedbackL1 = hpfL1 * hpfCoeffB2;
hpfFeedbackL2 = hpfL4 * hpfCoeffB1;
hpfFilteredL = ((((hpfFromHistoryL2 + hpfFromHistoryL1)) + hpfInputL)) - ((hpfFeedbackL2 + hpfFeedbackL1));

hpfL1 = fixdenorm(hpfL4);
hpfL2 = fixdenorm(hpfL3);
hpfL3 = fixdenorm(lpfMixedL);
hpfL4 = fixdenorm(hpfFilteredL);

// Canal izquierdo - Segunda etapa HPF (para 24 dB/oct)
hpfStage2InputL = hpfFilteredL * hpfCoeffA2;
hpfStage2FromHistoryL1 = hpfL7 * hpfCoeffA1;
hpfStage2FromHistoryL2 = hpfL6 * hpfCoeffA0;
hpfStage2FeedbackL1 = hpfL5 * hpfCoeffB2;
hpfStage2FeedbackL2 = hpfL8 * hpfCoeffB1;
hpfStage2FilteredL = ((((hpfStage2FromHistoryL2 + hpfStage2FromHistoryL1)) + hpfStage2InputL)) - ((hpfStage2FeedbackL2 + hpfStage2FeedbackL1));

hpfL5 = fixdenorm(hpfL8);
hpfL6 = fixdenorm(hpfL7);
hpfL7 = fixdenorm(hpfFilteredL);
hpfL8 = fixdenorm(hpfStage2FilteredL);

hpfFinalL = hpfOrderDiscrete == 0 ? hpfFilteredL : hpfStage2FilteredL;

// Canal derecho - Primera etapa HPF (12 dB/oct)
hpfInputR = lpfMixedR * hpfCoeffA2;
hpfFromHistoryR1 = hpfR3 * hpfCoeffA1;
hpfFromHistoryR2 = hpfR2 * hpfCoeffA0;
hpfFeedbackR1 = hpfR1 * hpfCoeffB2;
hpfFeedbackR2 = hpfR4 * hpfCoeffB1;
hpfFilteredR = ((((hpfFromHistoryR2 + hpfFromHistoryR1)) + hpfInputR)) - ((hpfFeedbackR2 + hpfFeedbackR1));

hpfR1 = fixdenorm(hpfR4);
hpfR2 = fixdenorm(hpfR3);
hpfR3 = fixdenorm(lpfMixedR);
hpfR4 = fixdenorm(hpfFilteredR);

// Canal derecho - Segunda etapa HPF (para 24 dB/oct)
hpfStage2InputR = hpfFilteredR * hpfCoeffA2;
hpfStage2FromHistoryR1 = hpfR7 * hpfCoeffA1;
hpfStage2FromHistoryR2 = hpfR6 * hpfCoeffA0;
hpfStage2FeedbackR1 = hpfR5 * hpfCoeffB2;
hpfStage2FeedbackR2 = hpfR8 * hpfCoeffB1;
hpfStage2FilteredR = ((((hpfStage2FromHistoryR2 + hpfStage2FromHistoryR1)) + hpfStage2InputR)) - ((hpfStage2FeedbackR2 + hpfStage2FeedbackR1));

hpfR5 = fixdenorm(hpfR8);
hpfR6 = fixdenorm(hpfR7);
hpfR7 = fixdenorm(hpfFilteredR);
hpfR8 = fixdenorm(hpfStage2FilteredR);

hpfFinalR = hpfOrderDiscrete == 0 ? hpfFilteredR : hpfStage2FilteredR;

// Señal final filtrada
lFiltered = mix(lpfMixedL, hpfFinalL, smoothScEnable);
rFiltered = mix(lpfMixedR, hpfFinalR, smoothScEnable);

// -----------------------------------------------------------------------------
// INPUT TRIM
// -----------------------------------------------------------------------------
lTrimmed = lFiltered * inputTrimLinear;
rTrimmed = rFiltered * inputTrimLinear;

// -----------------------------------------------------------------------------
// FILTRO TILT PRE-DISTORSIÓN
// -----------------------------------------------------------------------------
fc = 800.0;
q = 0.7071;

// Cálculo de coeficientes para Tilt (invertido para UI intuitiva)
tiltGain = dbtoa(-tiltDb);
omega = (fc * twopi) / samplerate;
sn = sin(omega);
cs = cos(omega);
A = sqrt(tiltGain);
beta = sqrt((A * A + 1) / q - (A - 1) * (A - 1));

// Coeficientes Low Shelf
b0Ls = 1 / ((A + 1) + (A - 1) * cs + beta * sn);
a0Ls = A * ((A + 1) - (A - 1) * cs + beta * sn) * b0Ls;
a1Ls = 2 * A * ((A - 1) - (A + 1) * cs) * b0Ls;
a2Ls = A * ((A + 1) - (A - 1) * cs - beta * sn) * b0Ls;
b1Ls = -2 * ((A - 1) + (A + 1) * cs) * b0Ls;
b2Ls = ((A + 1) + (A - 1) * cs - beta * sn) * b0Ls;

// Aplicar Low Shelf
lLs = a0Ls * lTrimmed + a1Ls * tiltL2 + a2Ls * tiltL1 - b1Ls * tiltL4 - b2Ls * tiltL3;
tiltL1 = tiltL2;
tiltL2 = lTrimmed;
tiltL3 = tiltL4;
tiltL4 = lLs;

rLs = a0Ls * rTrimmed + a1Ls * tiltR2 + a2Ls * tiltR1 - b1Ls * tiltR4 - b2Ls * tiltR3;
tiltR1 = tiltR2;
tiltR2 = rTrimmed;
tiltR3 = tiltR4;
tiltR4 = rLs;

// Coeficientes High Shelf
aInv = sqrt(1/tiltGain);
betaHs = sqrt((aInv * aInv + 1) / q - (aInv - 1) * (aInv - 1));

b0Hs = 1 / ((aInv + 1) - (aInv - 1) * cs + betaHs * sn);
a0Hs = aInv * ((aInv + 1) + (aInv - 1) * cs + betaHs * sn) * b0Hs;
a1Hs = -2 * aInv * ((aInv - 1) + (aInv + 1) * cs) * b0Hs;
a2Hs = aInv * ((aInv + 1) + (aInv - 1) * cs - betaHs * sn) * b0Hs;
b1Hs = 2 * ((aInv - 1) - (aInv + 1) * cs) * b0Hs;
b2Hs = ((aInv + 1) - (aInv - 1) * cs - betaHs * sn) * b0Hs;

lTilt = a0Hs * lLs + a1Hs * tiltL2 + a2Hs * tiltL1 - b1Hs * tiltL4 - b2Hs * tiltL3;
rTilt = a0Hs * rLs + a1Hs * tiltR2 + a2Hs * tiltR1 - b1Hs * tiltR4 - b2Hs * tiltR3;

// -----------------------------------------------------------------------------
// SALIDAS
// -----------------------------------------------------------------------------
out1 = lTilt;      // L procesado completo (filtrado + trim + tilt)
out2 = rTilt;      // R procesado completo
out3 = lTrimmed;   // L post-trim para medidores (sin tilt)
out4 = rTrimmed;   // R post-trim para medidores
