// =============================================================================
// EFFECTS CHAIN BLOCK - Bit Crusher & Downsampling
// =============================================================================
// Procesamiento de efectos adicionales post-distorsión
//
// ENTRADAS:
// - in1: Audio L distorsionado
// - in2: Audio R distorsionado
//
// SALIDAS:
// - out1: L procesado con bit crusher y downsampling
// - out2: R procesado con bit crusher y downsampling
// =============================================================================

// -----------------------------------------------------------------------------
// FUNCIONES
// -----------------------------------------------------------------------------

// Bit Crusher - Reduce la resolución de bits
bitCrusher(inl, inr, bits) {
    steps = pow(2, bits) - 1;
    invSteps = 1 / steps;
    l = ceil(inl * steps) * invSteps;
    r = ceil(inr * steps) * invSteps;
    return l, r;
}

// -----------------------------------------------------------------------------
// PARÁMETROS
// -----------------------------------------------------------------------------
Param g_BITS(16, min=3, default=16, max=16);
Param h_BITSON(0, min=0, default=0, max=1);
Param m_DOWNSAMPLE(0, min=0, default=0, max=99);  // Factor de downsampling
Param n_DOWNSAMPLEON(0, min=0, default=0, max=1); // Activar downsampling

// HISTORIALES
History hBits(0);
History hBitson(0);
History hDownsample(0);
History hDownsampleOn(0);

// Historiales para el downsampler con phasor
History dsPhasor(0);

// CONSTANTES
smoothFactor = 0.999;

// =============================================================================
// PROCESAMIENTO
// =============================================================================

// Entradas
processedL = in1;
processedR = in2;

// Smoothing de parámetros
hBits = hBits * smoothFactor + g_BITS * (1 - smoothFactor);
bits = hBits;

hBitson = hBitson * smoothFactor + h_BITSON * (1 - smoothFactor);
bitson = hBitson;

hDownsample = hDownsample * smoothFactor + m_DOWNSAMPLE * (1 - smoothFactor);

hDownsampleOn = hDownsampleOn * smoothFactor + n_DOWNSAMPLEON * (1 - smoothFactor);
downsampleOn = hDownsampleOn;

// -----------------------------------------------------------------------------
// BIT CRUSHER
// -----------------------------------------------------------------------------
bitL, bitR = bitCrusher(processedL, processedR, bits);

// DC Blocker después del bit crusher
bcL = dcblock(bitL);
bcR = dcblock(bitR);

// Mezclar señal original con bit crushed
withBitCrusherL = mix(processedL, bcL, bitson);
withBitCrusherR = mix(processedR, bcR, bitson);

// -----------------------------------------------------------------------------
// DOWNSAMPLING (con phasor y latch)
// -----------------------------------------------------------------------------
// Calcular frecuencia del decimador basada en el parámetro
// Convertir el parámetro (0-99) a factor de decimación (1-100)
deciFactor = hDownsample + 1;
deciFreq = (samplerate * 0.5) / deciFactor;

// Generar phasor para el downsampling
dsPhasor = phasor(deciFreq, 0);

// Crear trigger cuando el phasor cruza 0.5
dsTrigger = dsPhasor > 0.5;

// Usar latch para mantener las muestras
dsHeldL = latch(withBitCrusherL, dsTrigger);
dsHeldR = latch(withBitCrusherR, dsTrigger);

// Aplicar downsampling
wetFinalL = mix(withBitCrusherL, dsHeldL, downsampleOn);
wetFinalR = mix(withBitCrusherR, dsHeldR, downsampleOn);

// -----------------------------------------------------------------------------
// SALIDAS
// -----------------------------------------------------------------------------
out1 = wetFinalL;  // L con efectos
out2 = wetFinalR;  // R con efectos
