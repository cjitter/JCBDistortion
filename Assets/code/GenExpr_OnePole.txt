// =============================================================================
// MULTI-ALGORITHM DISTORTION WITH SIMPLE WORKING FILTERS
// =============================================================================
// Plugin de distorsión con múltiples algoritmos y morphing continuo
// Filtros HPF/LPF simples que funcionan correctamente
// Dry/Wet mezcla señal original (pre-trim) con señal completamente procesada
// =============================================================================

// -----------------------------------------------------------------------------
// FUNCIONES DE DISTORSIÓN (en orden de modo)
// -----------------------------------------------------------------------------

// MODO 0 - Soft Clipping - Saturación suave con función cúbica
softclip(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría (armónicos pares)
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    // Aplicar drive y normalizar
    lNorm = (lWithDC * dr) / cell;
    rNorm = (rWithDC * dr) / cell;
    
    lCubic = lNorm - (lNorm * lNorm * lNorm) / 3;
    rCubic = rNorm - (rNorm * rNorm * rNorm) / 3;
    
    lLimited = sign(lNorm) * (2.0 / 3.0);
    rLimited = sign(rNorm) * (2.0 / 3.0);
    
    lOut = (abs(lNorm) <= 1) ? lCubic : lLimited;
    rOut = (abs(rNorm) <= 1) ? rCubic : rLimited;
    
    return lOut * cell, rOut * cell;
}

// MODO 1 - Sigmoid - Curva en S para saturación suave
sigmoid(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    factor = (-1) * dr;
    l = (2 * (1 / (1 + exp(factor * lWithDC)))) - 1;
    r = (2 * (1 / (1 + exp(factor * rWithDC)))) - 1;
    
    // Aplicar ceiling para limitar la salida
    lOut = clip(l * cell, -cell, cell);
    rOut = clip(r * cell, -cell, cell);
    
    return lOut, rOut;
}

// MODO 2 - Rectificador Full Wave - Bipolar con compensación de ganancia
rectF(inl, inr, dr, dc, cell) {
    // Añadir DC offset para cambiar el punto de rectificación
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    l = sign(lWithDC) * abs(lWithDC * dr) * 0.707;
    r = sign(rWithDC) * abs(rWithDC * dr) * 0.707;
    lOut = clip(l, -cell, cell);
    rOut = clip(r, -cell, cell);
    return lOut, rOut;
}

// MODO 3 - Fuzz Exponencial 1 - Distorsión tipo fuzz con curva exponencial
fuzzExp1(inl, inr, dr, dc, cell) {
    // Añadir DC offset ANTES del procesamiento para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    signl = sign(lWithDC);
    signr = sign(rWithDC);
    
    lScaled = abs(lWithDC * dr);
    rScaled = abs(rWithDC * dr);
    
    l = signl * (1 - exp(-lScaled));
    r = signr * (1 - exp(-rScaled));
    
    lOut = clip(l, -cell, cell);
    rOut = clip(r, -cell, cell);
    return lOut, rOut;
}

// MODO 4 - Tangente Hiperbólica - Distorsión suave tipo saturación de cinta
tangenteHiperbolica(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    l = clip(lWithDC * dr, -cell, cell);
    r = clip(rWithDC * dr, -cell, cell);
    lOut = (tanh(l)) / (tanh(dr));
    rOut = (tanh(r)) / (tanh(dr));
    return lOut, rOut;
}

// MODO 5 - Rectificador Half Wave - Solo valores positivos
rectH(inl, inr, dr, dc, cell) {
    // Añadir DC offset para cambiar el punto de rectificación
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    lPositive = max(lWithDC, 0);
    rPositive = max(rWithDC, 0);
    l = clip((lPositive * dr) * 0.5, -cell, cell);
    r = clip((rPositive * dr) * 0.5, -cell, cell);
    return l, r;
}

// MODO 6 - Arctangente puro - Distorsión suave con compresión natural
arctangent(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    lScaled = lWithDC * dr * 2;
    rScaled = rWithDC * dr * 2;
    
    l = (2 / pi) * atan(lScaled);
    r = (2 / pi) * atan(rScaled);
    
    lOut = l * cell;
    rOut = r * cell;
    
    return lOut, rOut;
}

// MODO 7 - Hard Clip - Recorte abrupto de la señal
hardClip(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    // Aplicar drive y calcular threshold
    lDriven = lWithDC * dr;
    rDriven = rWithDC * dr;
    
    // Clipear a ±cell
    l = (lDriven > cell) ? cell : ((lDriven < -cell) ? -cell : lDriven);
    r = (rDriven > cell) ? cell : ((rDriven < -cell) ? -cell : rDriven);
    
    return l, r;
}

// Bit Crusher - Reduce la resolución de bits
bitCrusher(inl, inr, bits) {
    steps = pow(2, bits) - 1;
    invSteps = 1 / steps;
    l = ceil(inl * steps) * invSteps;
    r = ceil(inr * steps) * invSteps;
    return l, r;
}

// -----------------------------------------------------------------------------
// PARÁMETROS
// -----------------------------------------------------------------------------
Param a_DRYWET(1, min=0, default=1, max=1);
Param b_DRIVE(1, min=1, default=1, max=50);
Param c_DC(0, min=0, default=0, max=1);         // DC offset - añade armónicos pares (asimetría)
Param d_MODE(1, min=0, default=0, max=7);       // Continuo 0-7 (8 algoritmos)
Param e_CEILING(0, min=-20, default=0, max=6);
Param f_BYPASS(0, min=0, default=0, max=1);
Param g_BITS(16, min=3, default=16, max=16);
Param h_BITSON(0, min=0, default=0, max=1);
Param i_TILT(0, min=-6, default=0, max=6);

// Parámetros de filtros HPF/LPF
Param j_HPF(20, min=20, default=20, max=20000);       // Input HPF frequency (Hz)
Param k_LPF(20000, min=20, default=20000, max=20000); // Input LPF frequency (Hz)
Param l_SC(0, min=0, default=0, max=1);               // Input filter enable

// Parámetros existentes
Param k_INPUT(0, min=-12, default=0, max=12);   // Input trim gain
Param l_OUTPUT(0, min=-12, default=0, max=12);  // Output makeup gain
Param m_DOWNSAMPLE(0, min=0, default=0, max=99); // Factor de downsampling (0 = sin efecto)
Param n_DOWNSAMPLEON(0, min=0, default=0, max=1); // Activar downsampling

// -----------------------------------------------------------------------------
// HISTORIALES PARA SMOOTHING
// -----------------------------------------------------------------------------
History hDrive(0);
History hDc(0);
History hDrywet(0);
History hBits(0);
History hBitson(0);
History hTilt(0);
History hInput(0);
History hOutput(0);
History hMode(0);     // Para suavizar cambios de modo

History hDownsample(0); // Para suavizar factor de downsampling
History hDownsampleOn(0); // Para suavizar activación de downsampling
History hBypass(0);   // Para suavizar bypass y evitar clicks

// Historiales para filtros de 1 polo (más simples)
History hpfL_z1(0);
History hpfR_z1(0);
History lpfL_z1(0);
History lpfR_z1(0);

// Historiales para smoothing de filtros
History hpfFreqHistory(0);
History lpfFreqHistory(0);
History scEnableHistory(0);

// Historiales para el downsampler con phasor
History dsPhasor(0);

// Historiales para filtros Tilt
History tiltL1(0), tiltL2(0), tiltL3(0), tiltL4(0);
History tiltR1(0), tiltR2(0), tiltR3(0), tiltR4(0);

// -----------------------------------------------------------------------------
// PROCESAMIENTO PRINCIPAL
// -----------------------------------------------------------------------------

// Entrada
lIn = in1;
rIn = in2;

// Smoothing de parámetros
smoothFactor = 0.999;
hDrive = hDrive * smoothFactor + b_DRIVE * (1 - smoothFactor);
drive = hDrive;
hDc = hDc * smoothFactor + c_DC * (1 - smoothFactor);
dc = hDc;
hDrywet = hDrywet * smoothFactor + a_DRYWET * (1 - smoothFactor);
drywet = hDrywet;
hBits = hBits * smoothFactor + g_BITS * (1 - smoothFactor);
bits = hBits;
hBitson = hBitson * smoothFactor + h_BITSON * (1 - smoothFactor);
bitson = hBitson;
hTilt = hTilt * smoothFactor + i_TILT * (1 - smoothFactor);
tiltDb = hTilt;
hInput = hInput * smoothFactor + k_INPUT * (1 - smoothFactor);
inputTrimDb = hInput;
hOutput = hOutput * smoothFactor + l_OUTPUT * (1 - smoothFactor);
outputMakeupDb = hOutput;

// Suavizado especial para MODE con factor más agresivo para evitar clicks
modeSmoothFactor = 0.99;  // Más rápido que otros parámetros pero aún suave
hMode = hMode * modeSmoothFactor + d_MODE * (1 - modeSmoothFactor);
smoothedMode = hMode;

// Suavizado del downsampling
hDownsample = hDownsample * smoothFactor + m_DOWNSAMPLE * (1 - smoothFactor);
hDownsampleOn = hDownsampleOn * smoothFactor + n_DOWNSAMPLEON * (1 - smoothFactor);
downsampleOn = hDownsampleOn;

// Suavizado del bypass
hBypass = hBypass * smoothFactor + (1 - f_BYPASS) * (1 - smoothFactor);
bypass = hBypass;

// Suavizado de parámetros de filtros
smoothHpfFreq = (hpfFreqHistory * smoothFactor) + (j_HPF * (1 - smoothFactor));
hpfFreqHistory = fixdenorm(smoothHpfFreq);

smoothLpfFreq = (lpfFreqHistory * smoothFactor) + (k_LPF * (1 - smoothFactor));
lpfFreqHistory = fixdenorm(smoothLpfFreq);

smoothScEnable = (scEnableHistory * smoothFactor) + (l_SC * (1 - smoothFactor));
scEnableHistory = fixdenorm(smoothScEnable);

// Conversiones
ceiling = dbtoa(e_CEILING);
inputTrimLinear = dbtoa(inputTrimDb);
outputMakeupLinear = dbtoa(outputMakeupDb);

// -----------------------------------------------------------------------------
// INPUT TRIM
// -----------------------------------------------------------------------------
lTrimmed = lIn * inputTrimLinear;
rTrimmed = rIn * inputTrimLinear;

// -----------------------------------------------------------------------------
// FILTROS DE 1 POLO SIMPLES (6 dB/oct)
// -----------------------------------------------------------------------------
// Estos filtros son más simples y siempre funcionan

// Coeficiente HPF (1 polo)
hpf_freq = clip(smoothHpfFreq, 20, 20000);
hpf_coeff = exp(-2 * pi * hpf_freq / samplerate);

// Procesamiento HPF
hpfL_out = lTrimmed - hpfL_z1;
hpfL_z1 = lTrimmed - (hpfL_out * hpf_coeff);

hpfR_out = rTrimmed - hpfR_z1;
hpfR_z1 = rTrimmed - (hpfR_out * hpf_coeff);

// Coeficiente LPF (1 polo)
lpf_freq = clip(smoothLpfFreq, 20, 20000);
lpf_coeff = 2 * pi * lpf_freq / samplerate;
lpf_coeff = clip(lpf_coeff, 0, 1);

// Procesamiento LPF (aplicado a la salida del HPF)
lpfL_z1 = lpfL_z1 + lpf_coeff * (hpfL_out - lpfL_z1);
lpfR_z1 = lpfR_z1 + lpf_coeff * (hpfR_out - lpfR_z1);

// Señal filtrada
filteredL = lpfL_z1;
filteredR = lpfR_z1;

// Mezclar señal filtrada con original según filter enable
lFiltered = mix(lTrimmed, filteredL, smoothScEnable);
rFiltered = mix(rTrimmed, filteredR, smoothScEnable);

// -----------------------------------------------------------------------------
// FILTRO TILT PRE-DISTORSIÓN
// -----------------------------------------------------------------------------
fc = 800.0;
q = 0.7071;

// Cálculo de coeficientes para Tilt (invertido para UI intuitiva)
tiltGain = dbtoa(-tiltDb);
omega = (fc * twopi) / samplerate;
sn = sin(omega);
cs = cos(omega);
A = sqrt(tiltGain);
beta = sqrt((A * A + 1) / q - (A - 1) * (A - 1));

// Coeficientes Low Shelf
b0Ls = 1 / ((A + 1) + (A - 1) * cs + beta * sn);
a0Ls = A * ((A + 1) - (A - 1) * cs + beta * sn) * b0Ls;
a1Ls = 2 * A * ((A - 1) - (A + 1) * cs) * b0Ls;
a2Ls = A * ((A + 1) - (A - 1) * cs - beta * sn) * b0Ls;
b1Ls = -2 * ((A - 1) + (A + 1) * cs) * b0Ls;
b2Ls = ((A + 1) + (A - 1) * cs - beta * sn) * b0Ls;

// Aplicar Low Shelf
lLs = a0Ls * lFiltered + a1Ls * tiltL2 + a2Ls * tiltL1 - b1Ls * tiltL4 - b2Ls * tiltL3;
tiltL1 = tiltL2;
tiltL2 = lFiltered;
tiltL3 = tiltL4;
tiltL4 = lLs;

rLs = a0Ls * rFiltered + a1Ls * tiltR2 + a2Ls * tiltR1 - b1Ls * tiltR4 - b2Ls * tiltR3;
tiltR1 = tiltR2;
tiltR2 = rFiltered;
tiltR3 = tiltR4;
tiltR4 = rLs;

// Coeficientes High Shelf
aInv = sqrt(1/tiltGain);
betaHs = sqrt((aInv * aInv + 1) / q - (aInv - 1) * (aInv - 1));

b0Hs = 1 / ((aInv + 1) - (aInv - 1) * cs + betaHs * sn);
a0Hs = aInv * ((aInv + 1) + (aInv - 1) * cs + betaHs * sn) * b0Hs;
a1Hs = -2 * aInv * ((aInv - 1) + (aInv + 1) * cs) * b0Hs;
a2Hs = aInv * ((aInv + 1) + (aInv - 1) * cs - betaHs * sn) * b0Hs;
b1Hs = 2 * ((aInv - 1) - (aInv + 1) * cs) * b0Hs;
b2Hs = ((aInv + 1) - (aInv - 1) * cs - betaHs * sn) * b0Hs;

lTilt = a0Hs * lLs + a1Hs * tiltL2 + a2Hs * tiltL1 - b1Hs * tiltL4 - b2Hs * tiltL3;
rTilt = a0Hs * rLs + a1Hs * tiltR2 + a2Hs * tiltR1 - b1Hs * tiltR4 - b2Hs * tiltR3;

// -----------------------------------------------------------------------------
// PROCESAMIENTO DE DISTORSIÓN CON MORPHING
// -----------------------------------------------------------------------------

// Ejecutar TODOS los algoritmos con implementación consistente de DC
softL, softR = softclip(lTilt, rTilt, drive, dc, ceiling);
sigmL, sigmR = sigmoid(lTilt, rTilt, drive, dc, ceiling);
rectL, rectR = rectF(lTilt, rTilt, drive, dc, ceiling);
fuzz1L, fuzz1R = fuzzExp1(lTilt, rTilt, drive, dc, ceiling);
tanhL, tanhR = tangenteHiperbolica(lTilt, rTilt, drive, dc, ceiling);
recthL, recthR = rectH(lTilt, rTilt, drive, dc, ceiling);
atanL, atanR = arctangent(lTilt, rTilt, drive, dc, ceiling);
hardL, hardR = hardClip(lTilt, rTilt, drive, dc, ceiling);

// Sistema de morphing continuo
mode = smoothedMode;  // Usar el modo suavizado

// Calcular pesos (ahora solo 8 algoritmos)
w0 = max(0, 1 - abs(mode - 0));      // Softclip
w1 = max(0, 1 - abs(mode - 1));      // Sigmoid
w2 = max(0, 1 - abs(mode - 2));      // RectF
w3 = max(0, 1 - abs(mode - 3));      // Fuzz1
w4 = max(0, 1 - abs(mode - 4));      // TanH
w5 = max(0, 1 - abs(mode - 5));      // RectH
w6 = max(0, 1 - abs(mode - 6));      // Arctangent
w7 = max(0, 1 - abs(mode - 7));      // HardClip

// Normalizar pesos
sumWeights = w0 + w1 + w2 + w3 + w4 + w5 + w6 + w7 + 0.0001;
w0 /= sumWeights; w1 /= sumWeights; w2 /= sumWeights; w3 /= sumWeights;
w4 /= sumWeights; w5 /= sumWeights; w6 /= sumWeights; w7 /= sumWeights;

// Mezclar algoritmos
distL = softL * w0 + sigmL * w1 + rectL * w2 + fuzz1L * w3 +
        tanhL * w4 + recthL * w5 + atanL * w6 + hardL * w7;

distR = softR * w0 + sigmR * w1 + rectR * w2 + fuzz1R * w3 +
        tanhR * w4 + recthR * w5 + atanR * w6 + hardR * w7;

// DC Blocker
processedL = dcblock(distL);
processedR = dcblock(distR);

// -----------------------------------------------------------------------------
// BIT CRUSHER Y DOWNSAMPLING OPCIONAL (ANTES DEL DRY/WET)
// -----------------------------------------------------------------------------
// Bit Crusher
bitL, bitR = bitCrusher(processedL, processedR, bits);
bcL = dcblock(bitL);
bcR = dcblock(bitR);

withBitCrusherL = mix(processedL, bcL, bitson);
withBitCrusherR = mix(processedR, bcR, bitson);

// Downsampling con phasor y latch
// Calcular frecuencia del decimador basada en el parámetro
// Convertir el parámetro (0-99) a factor de decimación (1-100)
deciFactor = hDownsample + 1;
deciFreq = (samplerate * 0.5) / deciFactor;

// Generar phasor para el downsampling
dsPhasor = phasor(deciFreq, 0);

// Crear trigger cuando el phasor cruza 0.5
dsTrigger = dsPhasor > 0.5;

// Usar latch para mantener las muestras
dsHeldL = latch(withBitCrusherL, dsTrigger);
dsHeldR = latch(withBitCrusherR, dsTrigger);

// Aplicar downsampling
wetFinalL = mix(withBitCrusherL, dsHeldL, downsampleOn);
wetFinalR = mix(withBitCrusherR, dsHeldR, downsampleOn);

// -----------------------------------------------------------------------------
// OUTPUT MAKEUP (SOLO A LA SEÑAL WET)
// -----------------------------------------------------------------------------
// Aplicar makeup gain ANTES del dry/wet para que solo afecte a la señal procesada
wetWithMakeupL = wetFinalL * outputMakeupLinear;
wetWithMakeupR = wetFinalR * outputMakeupLinear;

// -----------------------------------------------------------------------------
// MEZCLA DRY/WET
// -----------------------------------------------------------------------------
// Dry = señal original sin procesar (pre-trim, pre-filtros)
// Wet = señal completamente procesada (trim + filtros + tilt + distorsión + efectos + makeup)
// Parámetro drywet: 0 = solo dry, 1 = solo wet
mixedL = mix(lIn, wetWithMakeupL, drywet);
mixedR = mix(rIn, wetWithMakeupR, drywet);

// -----------------------------------------------------------------------------
// SALIDA FINAL CON BYPASS
// -----------------------------------------------------------------------------
// Ya no aplicamos makeup aquí porque ya está en la señal wet
finalL = mixedL;
finalR = mixedR;

// DC Blocker final antes de la salida
finalDcBlockedL = dcblock(finalL);
finalDcBlockedR = dcblock(finalR);

// Salidas principales
out1 = mix(lIn, finalDcBlockedL, bypass);
out2 = mix(rIn, finalDcBlockedR, bypass);

// Salida 3 vacía para mantener consistencia
out3 = 0;

// Salidas post Input Trim (para medidores)
out4 = lTrimmed;  // L post trim
out5 = rTrimmed;  // R post trim
