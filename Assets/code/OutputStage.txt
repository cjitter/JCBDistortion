// =============================================================================
// OUTPUT STAGE BLOCK - Dry/Wet Mix, Output Gain, Band Recomposition & Bypass
// =============================================================================
// Procesamiento de salida con mezcla dry/wet, makeup gain,
// recomposición de bandas no procesadas y bypass
//
// ENTRADAS:
// - in1: Wet L (señal procesada con efectos)
// - in2: Wet R (señal procesada con efectos)
// - in3: Dry L compensado (desde input stage)
// - in4: Dry R compensado (desde input stage)
// - in5: L bandas no procesadas (desde input stage)
// - in6: R bandas no procesadas (desde input stage)
// - in7: L original sin procesar
// - in8: R original sin procesar
//
// SALIDAS:
// - out1: L final
// - out2: R final
// =============================================================================

// PARÁMETROS
Param a_DRYWET(1, min=0, default=1, max=1);
Param f_BYPASS(0, min=0, default=0, max=1);
Param l_OUTPUT(0, min=-12, default=0, max=12);  // Output makeup gain

// HISTORIALES
History hDrywet(0);
History hBypass(0);
History hOutput(0);

// CONSTANTES
smoothFactor = 0.999;

// =============================================================================
// PROCESAMIENTO
// =============================================================================

// Entradas
wetL = in1;                // Señal procesada con efectos
wetR = in2;                // Señal procesada con efectos
dryCompL = in3;            // Dry compensado (con allpass si crossover activo)
dryCompR = in4;            // Dry compensado
bypassBandsL = in5;        // Bandas no procesadas del crossover
bypassBandsR = in6;        // Bandas no procesadas del crossover
lOriginal = in7;           // Señal original sin procesar
rOriginal = in8;           // Señal original sin procesar

// Smoothing de parámetros
hDrywet = hDrywet * smoothFactor + a_DRYWET * (1 - smoothFactor);
drywet = hDrywet;

hBypass = hBypass * smoothFactor + (1 - f_BYPASS) * (1 - smoothFactor);
bypass = hBypass;

hOutput = hOutput * smoothFactor + l_OUTPUT * (1 - smoothFactor);
outputMakeupDb = hOutput;
outputMakeupLinear = dbtoa(outputMakeupDb);

// -----------------------------------------------------------------------------
// RECOMPOSICIÓN DE BANDAS Y OUTPUT MAKEUP
// -----------------------------------------------------------------------------
// Aplicar makeup gain a la señal wet y añadir las bandas no procesadas
wetWithMakeupL = (wetL * outputMakeupLinear) + bypassBandsL;
wetWithMakeupR = (wetR * outputMakeupLinear) + bypassBandsR;

// -----------------------------------------------------------------------------
// MEZCLA DRY/WET
// -----------------------------------------------------------------------------
// Dry = señal compensada (con allpass si hay crossover)
// Wet = señal procesada con makeup + bandas no procesadas
// Parámetro drywet: 0 = solo dry, 1 = solo wet
mixedL = mix(dryCompL, wetWithMakeupL, drywet);
mixedR = mix(dryCompR, wetWithMakeupR, drywet);

// -----------------------------------------------------------------------------
// DC BLOCKER FINAL
// -----------------------------------------------------------------------------
finalDcBlockedL = dcblock(mixedL);
finalDcBlockedR = dcblock(mixedR);

// -----------------------------------------------------------------------------
// BYPASS
// -----------------------------------------------------------------------------
// El bypass usa la señal original sin procesar
out1 = mix(lOriginal, finalDcBlockedL, bypass);
out2 = mix(rOriginal, finalDcBlockedR, bypass);