// =============================================================================
// MULTI-ALGORITHM DISTORTION WITH CONTINUOUS MORPHING
// =============================================================================
// Plugin de distorsión con múltiples algoritmos y morphing continuo
// Incluye filtros tilt pre/post, bit crusher opcional y controles completos
// =============================================================================

// -----------------------------------------------------------------------------
// FUNCIONES DE DISTORSIÓN (en orden de modo)
// -----------------------------------------------------------------------------

// MODO 0 - Soft Clipping - Saturación suave con función cúbica
// Fuente: Julius O. Smith III (CCRMA Stanford) - https://ccrma.stanford.edu/~jos/pasp/Soft_Clipping.html
softclip(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría (armónicos pares)
    lWithDC = inl + (dc * 0.05);
    rWithDC = inr + (dc * 0.05);
    
    // Aplicar drive y normalizar
    lNorm = (lWithDC * dr) / cell;
    rNorm = (rWithDC * dr) / cell;
    
    lCubic = lNorm - (lNorm * lNorm * lNorm) / 3;
    rCubic = rNorm - (rNorm * rNorm * rNorm) / 3;
    
    lLimited = sign(lNorm) * (2.0 / 3.0);
    rLimited = sign(rNorm) * (2.0 / 3.0);
    
    lOut = (abs(lNorm) <= 1) ? lCubic : lLimited;
    rOut = (abs(rNorm) <= 1) ? rCubic : rLimited;
    
    return lOut * cell, rOut * cell;
}

// MODO 1 - Sigmoid - Curva en S para saturación suave
// Fuente: Función logística estándar adaptada para audio
sigmoid(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.05);
    rWithDC = inr + (dc * 0.05);
    
    factor = (-1) * dr;
    l = (2 * (1 / (1 + exp(factor * lWithDC)))) - 1;
    r = (2 * (1 / (1 + exp(factor * rWithDC)))) - 1;
    
    // Aplicar ceiling para limitar la salida
    lOut = clip(l * cell, -cell, cell);
    rOut = clip(r * cell, -cell, cell);
    
    return lOut, rOut;
}

// MODO 2 - Rectificador Full Wave - Bipolar con compensación de ganancia
// Fuente: Diseño propio basado en rectificación con preservación de polaridad
rectF(inl, inr, dr, dc, cell) {
    // Añadir DC offset para cambiar el punto de rectificación
    lWithDC = inl + (dc * 0.05);
    rWithDC = inr + (dc * 0.05);
    
    l = sign(lWithDC) * abs(lWithDC * dr) * 0.707;
    r = sign(rWithDC) * abs(rWithDC * dr) * 0.707;
    lOut = clip(l, -cell, cell);
    rOut = clip(r, -cell, cell);
    return lOut, rOut;
}

// MODO 3 - Fuzz Exponencial 1 - Distorsión tipo fuzz con curva exponencial
// Fuente: DAFX de Udo Zölzer (fórmula corregida) - f(x) = sgn(x) * (1 - e^(-|x|))
fuzzExp1(inl, inr, dr, dc, cell) {
    // Añadir DC offset ANTES del procesamiento para generar asimetría
    lWithDC = inl + (dc * 0.05);
    rWithDC = inr + (dc * 0.05);
    
    signl = sign(lWithDC);
    signr = sign(rWithDC);
    
    lScaled = abs(lWithDC * dr);
    rScaled = abs(rWithDC * dr);
    
    l = signl * (1 - exp(-lScaled));
    r = signr * (1 - exp(-rScaled));
    
    lOut = clip(l, -cell, cell);
    rOut = clip(r, -cell, cell);
    return lOut, rOut;
}

// MODO 4 - Tangente Hiperbólica - Distorsión suave tipo saturación de cinta
// Fuente: Algoritmo clásico de saturación analógica - tanh(x)/tanh(drive)
tangenteHiperbolica(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.05);
    rWithDC = inr + (dc * 0.05);
    
    l = clip(lWithDC * dr, -cell, cell);
    r = clip(rWithDC * dr, -cell, cell);
    lOut = (tanh(l)) / (tanh(dr));
    rOut = (tanh(r)) / (tanh(dr));
    return lOut, rOut;
}

// MODO 5 - Rectificador Half Wave - Solo valores positivos
// Fuente: Emulación de diodo rectificador clásico
rectH(inl, inr, dr, dc, cell) {
    // Añadir DC offset para cambiar el punto de rectificación
    lWithDC = inl + (dc * 0.05);
    rWithDC = inr + (dc * 0.05);
    
    lPositive = max(lWithDC, 0);
    rPositive = max(rWithDC, 0);
    l = clip((lPositive * dr) * 0.5, -cell, cell);
    r = clip((rPositive * dr) * 0.5, -cell, cell);
    return l, r;
}

// MODO 6 - Arctangente puro - Distorsión suave con compresión natural
// Fuente: Función arctangente estándar para saturación suave
arctangent(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.05);
    rWithDC = inr + (dc * 0.05);
    
    lScaled = lWithDC * dr * 2;
    rScaled = rWithDC * dr * 2;
    
    l = (2 / pi) * atan(lScaled);
    r = (2 / pi) * atan(rScaled);
    
    lOut = l * cell;
    rOut = r * cell;
    
    return lOut, rOut;
}

// MODO 7 - Hard Clip - Recorte abrupto de la señal
// Fuente: Clipping digital clásico - saturación dura
hardClip(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.05);
    rWithDC = inr + (dc * 0.05);
    
    // Aplicar drive y calcular threshold
    lDriven = lWithDC * dr;
    rDriven = rWithDC * dr;
    
    // Clipear a ±cell
    l = (lDriven > cell) ? cell : ((lDriven < -cell) ? -cell : lDriven);
    r = (rDriven > cell) ? cell : ((rDriven < -cell) ? -cell : rDriven);
    
    return l, r;
}

// Bit Crusher - Reduce la resolución de bits
// Fuente: Algoritmo estándar de reducción de bits/cuantización
bitCrusher(inl, inr, bits) {
    steps = pow(2, bits) - 1;
    invSteps = 1 / steps;
    l = ceil(inl * steps) * invSteps;
    r = ceil(inr * steps) * invSteps;
    return l, r;
}

// -----------------------------------------------------------------------------
// PARÁMETROS
// -----------------------------------------------------------------------------
Param a_DRYWET(1, min=0, default=1, max=1);
Param b_DRIVE(1, min=1, default=1, max=50);
Param c_DC(0, min=0, default=0, max=1);         // DC offset - añade armónicos pares (asimetría)
Param d_MODE(1, min=0, default=0, max=7);       // Continuo 0-7 (8 algoritmos)
Param e_CEILING(0, min=-20, default=0, max=6);
Param f_BYPASS(0, min=0, default=0, max=1);
Param g_BITS(16, min=3, default=16, max=16);
Param h_BITSON(0, min=0, default=0, max=1);
Param i_TILT(0, min=-6, default=0, max=6);

Param k_INPUT(0, min=-12, default=0, max=12);   // Input trim gain
Param l_OUTPUT(0, min=-12, default=0, max=12);  // Output makeup gain
Param m_DOWNSAMPLE(0, min=0, default=0, max=99); // Factor de downsampling (0 = sin efecto)
Param n_DOWNSAMPLEON(0, min=0, default=0, max=1); // Activar downsampling

// -----------------------------------------------------------------------------
// HISTORIALES PARA SMOOTHING
// -----------------------------------------------------------------------------
History hDrive(0);
History hDc(0);
History hDrywet(0);
History hBits(0);
History hBitson(0);
History hTilt(0);
History hInput(0);
History hOutput(0);
History hMode(0);     // Para suavizar cambios de modo

History hDownsample(0); // Para suavizar factor de downsampling
History hDownsampleOn(0); // Para suavizar activación de downsampling
History hBypass(0);   // Para suavizar bypass y evitar clicks

// Historiales para el downsampler
History dsCounter(0);
History dsHeldL(0);
History dsHeldR(0);

// Historiales para filtros Tilt
History tiltL1(0), tiltL2(0), tiltL3(0), tiltL4(0);
History tiltR1(0), tiltR2(0), tiltR3(0), tiltR4(0);

// -----------------------------------------------------------------------------
// PROCESAMIENTO PRINCIPAL
// -----------------------------------------------------------------------------

// Entrada
lIn = in1;
rIn = in2;

// Smoothing de parámetros
smoothFactor = 0.999;
hDrive = hDrive * smoothFactor + b_DRIVE * (1 - smoothFactor);
drive = hDrive;
hDc = hDc * smoothFactor + c_DC * (1 - smoothFactor);
dc = hDc;
hDrywet = hDrywet * smoothFactor + a_DRYWET * (1 - smoothFactor);
drywet = hDrywet;
hBits = hBits * smoothFactor + g_BITS * (1 - smoothFactor);
bits = hBits;
hBitson = hBitson * smoothFactor + h_BITSON * (1 - smoothFactor);
bitson = hBitson;
hTilt = hTilt * smoothFactor + i_TILT * (1 - smoothFactor);
tiltDb = hTilt;
hInput = hInput * smoothFactor + k_INPUT * (1 - smoothFactor);
inputTrimDb = hInput;
hOutput = hOutput * smoothFactor + l_OUTPUT * (1 - smoothFactor);
outputMakeupDb = hOutput;

// Suavizado especial para MODE con factor más agresivo para evitar clicks
modeSmoothFactor = 0.99;  // Más rápido que otros parámetros pero aún suave
hMode = hMode * modeSmoothFactor + d_MODE * (1 - modeSmoothFactor);
smoothedMode = hMode;  // Definir la variable aquí

// Suavizado del downsampling
hDownsample = hDownsample * smoothFactor + m_DOWNSAMPLE * (1 - smoothFactor);
hDownsampleOn = hDownsampleOn * smoothFactor + n_DOWNSAMPLEON * (1 - smoothFactor);
downsampleOn = hDownsampleOn;

// Suavizado del bypass
hBypass = hBypass * smoothFactor + (1 - f_BYPASS) * (1 - smoothFactor);
bypass = hBypass;

// Conversiones
ceiling = dbtoa(e_CEILING);
inputTrimLinear = dbtoa(inputTrimDb);
outputMakeupLinear = dbtoa(outputMakeupDb);

// -----------------------------------------------------------------------------
// INPUT TRIM
// -----------------------------------------------------------------------------
lTrimmed = lIn * inputTrimLinear;
rTrimmed = rIn * inputTrimLinear;

// -----------------------------------------------------------------------------
// FILTRO TILT PRE-DISTORSIÓN
// -----------------------------------------------------------------------------
fc = 800.0;
q = 0.7071;

// Cálculo de coeficientes para Tilt (invertido para UI intuitiva)
tiltGain = dbtoa(-tiltDb);
omega = (fc * twopi) / samplerate;
sn = sin(omega);
cs = cos(omega);
A = sqrt(tiltGain);
beta = sqrt((A * A + 1) / q - (A - 1) * (A - 1));

// Coeficientes Low Shelf
b0Ls = 1 / ((A + 1) + (A - 1) * cs + beta * sn);
a0Ls = A * ((A + 1) - (A - 1) * cs + beta * sn) * b0Ls;
a1Ls = 2 * A * ((A - 1) - (A + 1) * cs) * b0Ls;
a2Ls = A * ((A + 1) - (A - 1) * cs - beta * sn) * b0Ls;
b1Ls = -2 * ((A - 1) + (A + 1) * cs) * b0Ls;
b2Ls = ((A + 1) + (A - 1) * cs - beta * sn) * b0Ls;

// Aplicar Low Shelf
lLs = a0Ls * lTrimmed + a1Ls * tiltL2 + a2Ls * tiltL1 - b1Ls * tiltL4 - b2Ls * tiltL3;
tiltL1 = tiltL2;
tiltL2 = lTrimmed;
tiltL3 = tiltL4;
tiltL4 = lLs;

rLs = a0Ls * rTrimmed + a1Ls * tiltR2 + a2Ls * tiltR1 - b1Ls * tiltR4 - b2Ls * tiltR3;
tiltR1 = tiltR2;
tiltR2 = rTrimmed;
tiltR3 = tiltR4;
tiltR4 = rLs;

// Coeficientes High Shelf
aInv = sqrt(1/tiltGain);
betaHs = sqrt((aInv * aInv + 1) / q - (aInv - 1) * (aInv - 1));

b0Hs = 1 / ((aInv + 1) - (aInv - 1) * cs + betaHs * sn);
a0Hs = aInv * ((aInv + 1) + (aInv - 1) * cs + betaHs * sn) * b0Hs;
a1Hs = -2 * aInv * ((aInv - 1) + (aInv + 1) * cs) * b0Hs;
a2Hs = aInv * ((aInv + 1) + (aInv - 1) * cs - betaHs * sn) * b0Hs;
b1Hs = 2 * ((aInv - 1) - (aInv + 1) * cs) * b0Hs;
b2Hs = ((aInv + 1) - (aInv - 1) * cs - betaHs * sn) * b0Hs;

lTilt = a0Hs * lLs + a1Hs * tiltL2 + a2Hs * tiltL1 - b1Hs * tiltL4 - b2Hs * tiltL3;
rTilt = a0Hs * rLs + a1Hs * tiltR2 + a2Hs * tiltR1 - b1Hs * tiltR4 - b2Hs * tiltR3;

// -----------------------------------------------------------------------------
// PROCESAMIENTO DE DISTORSIÓN CON MORPHING
// -----------------------------------------------------------------------------

// Ejecutar TODOS los algoritmos con implementación consistente de DC
// Ahora todas las funciones reciben los mismos parámetros y aplican DC de forma uniforme
softL, softR = softclip(lTilt, rTilt, drive, dc, ceiling);
sigmL, sigmR = sigmoid(lTilt, rTilt, drive, dc, ceiling);
rectL, rectR = rectF(lTilt, rTilt, drive, dc, ceiling);
fuzz1L, fuzz1R = fuzzExp1(lTilt, rTilt, drive, dc, ceiling);
tanhL, tanhR = tangenteHiperbolica(lTilt, rTilt, drive, dc, ceiling);
recthL, recthR = rectH(lTilt, rTilt, drive, dc, ceiling);
atanL, atanR = arctangent(lTilt, rTilt, drive, dc, ceiling);
hardL, hardR = hardClip(lTilt, rTilt, drive, dc, ceiling);

// Sistema de morphing continuo
mode = smoothedMode;  // Usar el modo suavizado

// Calcular pesos (ahora solo 8 algoritmos)
w0 = max(0, 1 - abs(mode - 0));      // Softclip
w1 = max(0, 1 - abs(mode - 1));      // Sigmoid
w2 = max(0, 1 - abs(mode - 2));      // RectF
w3 = max(0, 1 - abs(mode - 3));      // Fuzz1
w4 = max(0, 1 - abs(mode - 4));      // TanH
w5 = max(0, 1 - abs(mode - 5));      // RectH
w6 = max(0, 1 - abs(mode - 6));      // Arctangent
w7 = max(0, 1 - abs(mode - 7));      // HardClip

// Normalizar pesos
sumWeights = w0 + w1 + w2 + w3 + w4 + w5 + w6 + w7 + 0.0001;
w0 /= sumWeights; w1 /= sumWeights; w2 /= sumWeights; w3 /= sumWeights;
w4 /= sumWeights; w5 /= sumWeights; w6 /= sumWeights; w7 /= sumWeights;

// Mezclar algoritmos
distL = softL * w0 + sigmL * w1 + rectL * w2 + fuzz1L * w3 +
        tanhL * w4 + recthL * w5 + atanL * w6 + hardL * w7;

distR = softR * w0 + sigmR * w1 + rectR * w2 + fuzz1R * w3 +
        tanhR * w4 + recthR * w5 + atanR * w6 + hardR * w7;

// DC Blocker
processedL = dcblock(distL);
processedR = dcblock(distR);

// -----------------------------------------------------------------------------
// BIT CRUSHER Y DOWNSAMPLING OPCIONAL (ANTES DEL DRY/WET)
// -----------------------------------------------------------------------------
// Bit Crusher
bitL, bitR = bitCrusher(processedL, processedR, bits);
bcL = dcblock(bitL);
bcR = dcblock(bitR);

withBitCrusherL = mix(processedL, bcL, bitson);
withBitCrusherR = mix(processedR, bcR, bitson);

// Downsampling simple
// Incrementar contador
dsCounter = dsCounter + 1;

// Calcular cuántas muestras saltar (0 = ninguna, 99 = saltar 99)
skipSamples = floor(hDownsample) + 1;

// Si es momento de tomar nueva muestra o no hay downsampling
if (dsCounter >= skipSamples || hDownsample < 0.5) {
    dsHeldL = withBitCrusherL;
    dsHeldR = withBitCrusherR;
    dsCounter = 0;
}

// Aplicar downsampling
wetFinalL = mix(withBitCrusherL, dsHeldL, downsampleOn);
wetFinalR = mix(withBitCrusherR, dsHeldR, downsampleOn);

// -----------------------------------------------------------------------------
// MEZCLA DRY/WET
// -----------------------------------------------------------------------------
mixedL = mix(lTrimmed, wetFinalL, drywet);
mixedR = mix(rTrimmed, wetFinalR, drywet);

// -----------------------------------------------------------------------------
// SALIDA FINAL CON BYPASS Y OUTPUT MAKEUP
// -----------------------------------------------------------------------------
finalWithMakeupL = mixedL * outputMakeupLinear;
finalWithMakeupR = mixedR * outputMakeupLinear;

// DC Blocker final antes de la salida
finalDcBlockedL = dcblock(finalWithMakeupL);
finalDcBlockedR = dcblock(finalWithMakeupR);

// Salidas principales
out1 = mix(lIn, finalDcBlockedL, bypass);
out2 = mix(rIn, finalDcBlockedR, bypass);

// Salida 3 vacía para mantener consistencia
out3 = 0;

// Salidas post Input Trim (para medidores)
out4 = lTrimmed;  // L post trim
out5 = rTrimmed;  // R post trim