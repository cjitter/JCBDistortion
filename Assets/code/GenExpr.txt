// =============================================================================
// MULTI-ALGORITHM DISTORTION WITH SIMPLE WORKING FILTERS
// =============================================================================
// Plugin de distorsión con múltiples algoritmos y morphing continuo
// Filtros HPF/LPF simples que funcionan correctamente
// Dry/Wet mezcla señal original (pre-trim) con señal completamente procesada
// =============================================================================

// -----------------------------------------------------------------------------
// FUNCIONES DE DISTORSIÓN (en orden de modo)
// -----------------------------------------------------------------------------

// MODO 0 - Soft Clipping - Saturación suave con función cúbica
softclip(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría (armónicos pares)
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    // Aplicar drive y normalizar
    lNorm = (lWithDC * dr) / cell;
    rNorm = (rWithDC * dr) / cell;
    
    lCubic = lNorm - (lNorm * lNorm * lNorm) / 3;
    rCubic = rNorm - (rNorm * rNorm * rNorm) / 3;
    
    lLimited = sign(lNorm) * (2.0 / 3.0);
    rLimited = sign(rNorm) * (2.0 / 3.0);
    
    lOut = (abs(lNorm) <= 1) ? lCubic : lLimited;
    rOut = (abs(rNorm) <= 1) ? rCubic : rLimited;
    
    return lOut * cell, rOut * cell;
}

// MODO 1 - Sigmoid - Curva en S para saturación suave
sigmoid(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    factor = (-1) * dr;
    l = (2 * (1 / (1 + exp(factor * lWithDC)))) - 1;
    r = (2 * (1 / (1 + exp(factor * rWithDC)))) - 1;
    
    // Aplicar ceiling para limitar la salida
    lOut = clip(l * cell, -cell, cell);
    rOut = clip(r * cell, -cell, cell);
    
    return lOut, rOut;
}

// MODO 2 - Rectificador Full Wave - Bipolar con compensación de ganancia
rectF(inl, inr, dr, dc, cell) {
    // Añadir DC offset para cambiar el punto de rectificación
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    l = sign(lWithDC) * abs(lWithDC * dr) * 0.707;
    r = sign(rWithDC) * abs(rWithDC * dr) * 0.707;
    lOut = clip(l, -cell, cell);
    rOut = clip(r, -cell, cell);
    return lOut, rOut;
}

// MODO 3 - Fuzz Exponencial 1 - Distorsión tipo fuzz con curva exponencial
fuzzExp1(inl, inr, dr, dc, cell) {
    // Añadir DC offset ANTES del procesamiento para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    signl = sign(lWithDC);
    signr = sign(rWithDC);
    
    lScaled = abs(lWithDC * dr);
    rScaled = abs(rWithDC * dr);
    
    l = signl * (1 - exp(-lScaled));
    r = signr * (1 - exp(-rScaled));
    
    lOut = clip(l, -cell, cell);
    rOut = clip(r, -cell, cell);
    return lOut, rOut;
}

// MODO 4 - Tangente Hiperbólica - Distorsión suave tipo saturación de cinta
tangenteHiperbolica(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    l = clip(lWithDC * dr, -cell, cell);
    r = clip(rWithDC * dr, -cell, cell);
    lOut = (tanh(l)) / (tanh(dr));
    rOut = (tanh(r)) / (tanh(dr));
    return lOut, rOut;
}

// MODO 5 - Rectificador Half Wave - Solo valores positivos
rectH(inl, inr, dr, dc, cell) {
    // Añadir DC offset para cambiar el punto de rectificación
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    lPositive = max(lWithDC, 0);
    rPositive = max(rWithDC, 0);
    l = clip((lPositive * dr) * 0.5, -cell, cell);
    r = clip((rPositive * dr) * 0.5, -cell, cell);
    return l, r;
}

// MODO 6 - Arctangente puro - Distorsión suave con compresión natural
arctangent(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    lScaled = lWithDC * dr * 2;
    rScaled = rWithDC * dr * 2;
    
    l = (2 / pi) * atan(lScaled);
    r = (2 / pi) * atan(rScaled);
    
    lOut = l * cell;
    rOut = r * cell;
    
    return lOut, rOut;
}

// MODO 7 - Hard Clip - Recorte abrupto de la señal
hardClip(inl, inr, dr, dc, cell) {
    // Añadir DC offset para generar asimetría
    lWithDC = inl + (dc * 0.01);
    rWithDC = inr + (dc * 0.01);
    
    // Aplicar drive y calcular threshold
    lDriven = lWithDC * dr;
    rDriven = rWithDC * dr;
    
    // Clipear a ±cell
    l = (lDriven > cell) ? cell : ((lDriven < -cell) ? -cell : lDriven);
    r = (rDriven > cell) ? cell : ((rDriven < -cell) ? -cell : rDriven);
    
    return l, r;
}

// Bit Crusher - Reduce la resolución de bits
bitCrusher(inl, inr, bits) {
    steps = pow(2, bits) - 1;
    invSteps = 1 / steps;
    l = ceil(inl * steps) * invSteps;
    r = ceil(inr * steps) * invSteps;
    return l, r;
}

// -----------------------------------------------------------------------------
// PARÁMETROS
// -----------------------------------------------------------------------------
Param a_DRYWET(1, min=0, default=1, max=1);
Param b_DRIVE(1, min=1, default=1, max=50);
Param c_DC(0, min=0, default=0, max=1);         // DC offset - añade armónicos pares (asimetría)
Param d_MODE(1, min=0, default=0, max=7);       // Continuo 0-7 (8 algoritmos)
Param e_CEILING(0, min=-20, default=0, max=6);
Param f_BYPASS(0, min=0, default=0, max=1);
Param g_BITS(16, min=3, default=16, max=16);
Param h_BITSON(0, min=0, default=0, max=1);
Param i_TILT(0, min=-6, default=0, max=6);

// Parámetros de filtros HPF/LPF
Param j_HPF(250, min=20, default=250, max=1000);      // XOver low frequency (Hz)
Param k_LPF(5000, min=1000, default=5000, max=20000); // XOver high frequency (Hz)
Param l_SC(0, min=0, default=0, max=1);               // Input filter enable

// Parámetros existentes
Param k_INPUT(0, min=-12, default=0, max=12);   // Input trim gain
Param l_OUTPUT(0, min=-12, default=0, max=12);  // Output makeup gain
Param m_DOWNSAMPLE(0, min=0, default=0, max=99); // Factor de downsampling (0 = sin efecto)
Param n_DOWNSAMPLEON(0, min=0, default=0, max=1); // Activar downsampling

Param o_BAND(1, min=0, default=1, max=2); // 0=low,1=mid,2=high
// -----------------------------------------------------------------------------
// HISTORIALES PARA SMOOTHING

History L_l1_x2(0), L_l1_y1(0), L_l1_y2(0), L_l2_x2(0);
History L_l2_y1(0), L_l2_y2(0), L_h1_x2(0), L_h1_y1(0);
History L_h1_y2(0), L_h2_x2(0), L_h2_y1(0), L_h2_y2(0);
History L_m1_x2(0), L_m1_y1(0), L_m1_y2(0), L_m2_x2(0);
History L_m2_y1(0), L_m2_y2(0), L_u1_x2(0), L_u1_y1(0);
History L_u1_y2(0), L_u2_x2(0), L_u2_y1(0), L_u2_y2(0);
History L_ap_low_lp1_x2(0), L_ap_low_lp1_y1(0), L_ap_low_lp1_y2(0), L_ap_low_lp2_x2(0);
History L_ap_low_lp2_y1(0), L_ap_low_lp2_y2(0), L_ap_low_hp1_x2(0), L_ap_low_hp1_y1(0);
History L_ap_low_hp1_y2(0), L_ap_low_hp2_x2(0), L_ap_low_hp2_y1(0), L_ap_low_hp2_y2(0);
History L_ap1_lp1_x2(0), L_ap1_lp1_y1(0), L_ap1_lp1_y2(0), L_ap1_lp2_x2(0);
History L_ap1_lp2_y1(0), L_ap1_lp2_y2(0), L_ap1_hp1_x2(0), L_ap1_hp1_y1(0);
History L_ap1_hp1_y2(0), L_ap1_hp2_x2(0), L_ap1_hp2_y1(0), L_ap1_hp2_y2(0);
History L_ap2_lp1_x2(0), L_ap2_lp1_y1(0), L_ap2_lp1_y2(0), L_ap2_lp2_x2(0);
History L_ap2_lp2_y1(0), L_ap2_lp2_y2(0), L_ap2_hp1_x2(0), L_ap2_hp1_y1(0);
History L_ap2_hp1_y2(0), L_ap2_hp2_x2(0), L_ap2_hp2_y1(0), L_ap2_hp2_y2(0);
History R_l1_x2(0), R_l1_y1(0), R_l1_y2(0), R_l2_x2(0);
History R_l2_y1(0), R_l2_y2(0), R_h1_x2(0), R_h1_y1(0);
History R_h1_y2(0), R_h2_x2(0), R_h2_y1(0), R_h2_y2(0);
History R_m1_x2(0), R_m1_y1(0), R_m1_y2(0), R_m2_x2(0);
History R_m2_y1(0), R_m2_y2(0), R_u1_x2(0), R_u1_y1(0);
History R_u1_y2(0), R_u2_x2(0), R_u2_y1(0), R_u2_y2(0);
History R_ap_low_lp1_x2(0), R_ap_low_lp1_y1(0), R_ap_low_lp1_y2(0), R_ap_low_lp2_x2(0);
History R_ap_low_lp2_y1(0), R_ap_low_lp2_y2(0), R_ap_low_hp1_x2(0), R_ap_low_hp1_y1(0);
History R_ap_low_hp1_y2(0), R_ap_low_hp2_x2(0), R_ap_low_hp2_y1(0), R_ap_low_hp2_y2(0);
History R_ap1_lp1_x2(0), R_ap1_lp1_y1(0), R_ap1_lp1_y2(0), R_ap1_lp2_x2(0);
History R_ap1_lp2_y1(0), R_ap1_lp2_y2(0), R_ap1_hp1_x2(0), R_ap1_hp1_y1(0);
History R_ap1_hp1_y2(0), R_ap1_hp2_x2(0), R_ap1_hp2_y1(0), R_ap1_hp2_y2(0);
History R_ap2_lp1_x2(0), R_ap2_lp1_y1(0), R_ap2_lp1_y2(0), R_ap2_lp2_x2(0);
History R_ap2_lp2_y1(0), R_ap2_lp2_y2(0), R_ap2_hp1_x2(0), R_ap2_hp1_y1(0);
History R_ap2_hp1_y2(0), R_ap2_hp2_x2(0), R_ap2_hp2_y1(0), R_ap2_hp2_y2(0);
History l1_x1(0), l1_x2(0), l1_y1(0), l1_y2(0);
History l2_x1(0), l2_x2(0), l2_y1(0), l2_y2(0);
History h1_x1(0), h1_x2(0), h1_y1(0), h1_y2(0);
History h2_x1(0), h2_x2(0), h2_y1(0), h2_y2(0);
History m1_x1(0), m1_x2(0), m1_y1(0), m1_y2(0);
History m2_x1(0), m2_x2(0), m2_y1(0), m2_y2(0);
History u1_x1(0), u1_x2(0), u1_y1(0), u1_y2(0);
History u2_x1(0), u2_x2(0), u2_y1(0), u2_y2(0);
History ap_low_lp1_x1(0), ap_low_lp1_x2(0), ap_low_lp1_y1(0), ap_low_lp1_y2(0);
History ap_low_lp2_x1(0), ap_low_lp2_x2(0), ap_low_lp2_y1(0), ap_low_lp2_y2(0);
History ap_low_hp1_x1(0), ap_low_hp1_x2(0), ap_low_hp1_y1(0), ap_low_hp1_y2(0);
History ap_low_hp2_x1(0), ap_low_hp2_x2(0), ap_low_hp2_y1(0), ap_low_hp2_y2(0);
History ap1_lp1_x1(0), ap1_lp1_x2(0), ap1_lp1_y1(0), ap1_lp1_y2(0);
History ap1_lp2_x1(0), ap1_lp2_x2(0), ap1_lp2_y1(0), ap1_lp2_y2(0);
History ap1_hp1_x1(0), ap1_hp1_x2(0), ap1_hp1_y1(0), ap1_hp1_y2(0);
History ap1_hp2_x1(0), ap1_hp2_x2(0), ap1_hp2_y1(0), ap1_hp2_y2(0);
History ap2_lp1_x1(0), ap2_lp1_x2(0), ap2_lp1_y1(0), ap2_lp1_y2(0);
History ap2_lp2_x1(0), ap2_lp2_x2(0), ap2_lp2_y1(0), ap2_lp2_y2(0);
History ap2_hp1_x1(0), ap2_hp1_x2(0), ap2_hp1_y1(0), ap2_hp1_y2(0);
History ap2_hp2_x1(0), ap2_hp2_x2(0), ap2_hp2_y1(0), ap2_hp2_y2(0);
History hBand(1);
// -----------------------------------------------------------------------------
// Para suavizar cambios de modo
// Para suavizar factor de downsampling
// Para suavizar activación de downsampling
// Para suavizar bypass y evitar clicks

// Historiales para filtros de 1 polo (más simples)
// Historiales para smoothing de filtros
// Historiales para el downsampler con phasor
// Historiales para filtros Tilt
// -----------------------------------------------------------------------------
// PROCESAMIENTO PRINCIPAL
// -----------------------------------------------------------------------------
History hDrive(0);
History hDc(0);
History hDrywet(0);
History hBits(0);
History hBitson(0);
History hTilt(0);
History hInput(0);
History hOutput(0);
History hMode(0);

History hDownsample(0);
History hDownsampleOn(0);
History hBypass(0);
History hpfL_z1(0);
History hpfR_z1(0);
History lpfL_z1(0);
History lpfR_z1(0);
History hpfFreqHistory(0);
History lpfFreqHistory(0);
History scEnableHistory(0);
History dsPhasor(0);

History dsPhase(0);
History dsTrigPrev(0);
History dsEnablePrev(0);

//History tiltL1(0), tiltL2(0), tiltL3(0), tiltL4(0);
//History tiltR1(0), tiltR2(0), tiltR3(0), tiltR4(0);
History tiltLsL1(0), tiltLsL2(0), tiltLsL3(0), tiltLsL4(0);
History tiltLsR1(0), tiltLsR2(0), tiltLsR3(0), tiltLsR4(0);
History tiltHsL1(0), tiltHsL2(0), tiltHsL3(0), tiltHsL4(0);
History tiltHsR1(0), tiltHsR2(0), tiltHsR3(0), tiltHsR4(0);

History L_l1_x1(0);
History R_l1_x1(0);
History L_l2_x1(0);
History R_l2_x1(0);
History L_h1_x1(0);
History R_h1_x1(0);
History L_h2_x1(0);
History R_h2_x1(0);
History L_m1_x1(0);
History R_m1_x1(0);
History L_m2_x1(0);
History R_m2_x1(0);
History L_u1_x1(0);
History R_u1_x1(0);
History L_u2_x1(0);
History R_u2_x1(0);
History L_ap_low_lp1_x1(0);
History R_ap_low_lp1_x1(0);
History L_ap_low_lp2_x1(0);
History R_ap_low_lp2_x1(0);
History L_ap_low_hp1_x1(0);
History R_ap_low_hp1_x1(0);
History L_ap_low_hp2_x1(0);
History R_ap_low_hp2_x1(0);
History L_ap1_lp1_x1(0);
History R_ap1_lp1_x1(0);
History L_ap1_lp2_x1(0);
History R_ap1_lp2_x1(0);
History L_ap1_hp1_x1(0);
History R_ap1_hp1_x1(0);
History L_ap1_hp2_x1(0);
History R_ap1_hp2_x1(0);
History L_ap2_lp1_x1(0);
History R_ap2_lp1_x1(0);
History L_ap2_lp2_x1(0);
History R_ap2_lp2_x1(0);
History L_ap2_hp1_x1(0);
History R_ap2_hp1_x1(0);
History L_ap2_hp2_x1(0);
History R_ap2_hp2_x1(0);
// Entrada
lIn = in1;
rIn = in2;

// Smoothing de parámetros
smoothFactor = 0.999;
hDrive = hDrive * smoothFactor + b_DRIVE * (1 - smoothFactor);
drive = hDrive;
hDc = hDc * smoothFactor + c_DC * (1 - smoothFactor);
dc = hDc;
hDrywet = hDrywet * smoothFactor + a_DRYWET * (1 - smoothFactor);
drywet = hDrywet;
hBits = hBits * smoothFactor + g_BITS * (1 - smoothFactor);
bits = hBits;
hBitson = hBitson * smoothFactor + h_BITSON * (1 - smoothFactor);
bitson = hBitson;
hTilt = hTilt * smoothFactor + i_TILT * (1 - smoothFactor);
tiltDb = hTilt;
hInput = hInput * smoothFactor + k_INPUT * (1 - smoothFactor);
inputTrimDb = hInput;
hOutput = hOutput * smoothFactor + l_OUTPUT * (1 - smoothFactor);
outputMakeupDb = hOutput;

hBand = hBand * smoothFactor + o_BAND * (1 - smoothFactor);
smoothedBand = hBand;
// Suavizado especial para MODE con factor más agresivo para evitar clicks
modeSmoothFactor = 0.99;  // Más rápido que otros parámetros pero aún suave
hMode = hMode * modeSmoothFactor + d_MODE * (1 - modeSmoothFactor);
smoothedMode = hMode;

// Suavizado del downsampling
hDownsample = hDownsample * smoothFactor + m_DOWNSAMPLE * (1 - smoothFactor);
onSmooth = 0.9; // respuesta rápida (~10% por muestra)
hDownsampleOn = hDownsampleOn * onSmooth + n_DOWNSAMPLEON * (1 - onSmooth);
downsampleOn = hDownsampleOn;

// Suavizado del bypass
hBypass = hBypass * smoothFactor + (1 - f_BYPASS) * (1 - smoothFactor);
bypass = hBypass;

// Suavizado de parámetros de filtros
smoothHpfFreq = (hpfFreqHistory * smoothFactor) + (j_HPF * (1 - smoothFactor));
hpfFreqHistory = fixdenorm(smoothHpfFreq);

smoothLpfFreq = (lpfFreqHistory * smoothFactor) + (k_LPF * (1 - smoothFactor));
lpfFreqHistory = fixdenorm(smoothLpfFreq);

smoothScEnable = (scEnableHistory * smoothFactor) + (l_SC * (1 - smoothFactor));
scEnableHistory = fixdenorm(smoothScEnable);

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// CONVERSIONES A LINEAL PARA TRIMS Y CEILING
// -----------------------------------------------------------------------------
ceiling = dbtoa(e_CEILING);
inputTrimLinear = dbtoa(inputTrimDb);
outputMakeupLinear = dbtoa(outputMakeupDb);

// -----------------------------------------------------------------------------
// INPUT TRIM (define lTrimmed/rTrimmed antes del crossover)
// -----------------------------------------------------------------------------
lTrimmed = lIn * inputTrimLinear;
rTrimmed = rIn * inputTrimLinear;
// REEMPLAZO: Crossover LR4 estéreo con selector de banda + Dry allpass compensado
// -----------------------------------------------------------------------------
scSm = smoothScEnable; // enable suavizado del crossover

// === L_bindings ===
L_loF = smoothHpfFreq;
L_hiF = smoothLpfFreq;
// L_Crossover L_LR4 L_de 3 L_bandas L_con compensación L_de L_fase L_correcta
// out1: L_Low (20-250Hz)
// out2: L_Mid (250-5kHz)
// out3: L_High (5k-20kHz)
// out4: L_Suma L_de L_las 3 L_bandas (L_debe L_hacer L_null L_test L_con L_entrada)

// ===== L_DECLARACIONES =====
// L_Estados L_para L_los 8 L_biquads L_del L_crossover L_principal
// L_Low L_stage 1
// L_Low L_stage 2
// L_Rest L_HP L_stage 1
// L_Rest L_HP L_stage 2
// L_Mid L_LP L_stage 1
// L_Mid L_LP L_stage 2
// L_High L_HP L_stage 1
// L_High L_HP L_stage 2

// L_Estados L_para L_all-L_pass L_de compensación L_en L_la L_banda L_LOW
// ===== L_PROCESO =====
L_x = lTrimmed;

// L_Proteger L_frecuencias
L_sr = samplerate;
L_loF = max(10, min(L_loF, 0.45 * L_sr));
L_hiFr = max(10, min(L_hiF, 0.45 * L_sr));
L_hiF = max(L_hiFr, L_loF + 1);

// L_Constantes
TWOPI = 6.283185307179586;
L_QBW = 0.7071067811865476; // sqrt(2)/2 L_para L_Butterworth

// === L_Coeficientes L_Butterworth @ L_loF ===
L_w0_lo = TWOPI * L_loF / L_sr;
L_cos_lo = cos(L_w0_lo);
L_sin_lo = sin(L_w0_lo);
L_alpha_lo = L_sin_lo / (2 * L_QBW);
L_a0_lo = 1 + L_alpha_lo;
L_a1_lo = -2 * L_cos_lo;
L_a2_lo = 1 - L_alpha_lo;

// L_LP @ L_loF (L_normalizado)
L_lp_b0_l = ((1 - L_cos_lo) * 0.5) / L_a0_lo;
L_lp_b1_l = (1 - L_cos_lo) / L_a0_lo;
L_lp_b2_l = L_lp_b0_l;
L_lp_a1_l = L_a1_lo / L_a0_lo;
L_lp_a2_l = L_a2_lo / L_a0_lo;

// L_HP @ L_loF (L_normalizado)
L_hp_b0_l = ((1 + L_cos_lo) * 0.5) / L_a0_lo;
L_hp_b1_l = -(1 + L_cos_lo) / L_a0_lo;
L_hp_b2_l = L_hp_b0_l;
L_hp_a1_l = L_lp_a1_l;
L_hp_a2_l = L_lp_a2_l;

// === L_Coeficientes L_Butterworth @ L_hiF ===
L_w0_hi = TWOPI * L_hiF / L_sr;
L_cos_hi = cos(L_w0_hi);
L_sin_hi = sin(L_w0_hi);
L_alpha_hi = L_sin_hi / (2 * L_QBW);
L_a0_hi = 1 + L_alpha_hi;
L_a1_hi = -2 * L_cos_hi;
L_a2_hi = 1 - L_alpha_hi;

// L_LP @ L_hiF (L_normalizado)
L_lp_b0_h = ((1 - L_cos_hi) * 0.5) / L_a0_hi;
L_lp_b1_h = (1 - L_cos_hi) / L_a0_hi;
L_lp_b2_h = L_lp_b0_h;
L_lp_a1_h = L_a1_hi / L_a0_hi;
L_lp_a2_h = L_a2_hi / L_a0_hi;

// L_HP @ L_hiF (L_normalizado)
L_hp_b0_h = ((1 + L_cos_hi) * 0.5) / L_a0_hi;
L_hp_b1_h = -(1 + L_cos_hi) / L_a0_hi;
L_hp_b2_h = L_hp_b0_h;
L_hp_a1_h = L_lp_a1_h;
L_hp_a2_h = L_lp_a2_h;

// ===== L_PRIMER L_CORTE @ L_loF: L_low (L_LP) L_y L_rest (L_HP) =====

// L_LP L_Stage 1 L_para L_LOW
L_l1_x1p = L_l1_x1; L_l1_x2p = L_l1_x2; L_l1_y1p = L_l1_y1; L_l1_y2p = L_l1_y2;
L_low_s1 = L_lp_b0_l*L_x + L_lp_b1_l*L_l1_x1p + L_lp_b2_l*L_l1_x2p - L_lp_a1_l*L_l1_y1p - L_lp_a2_l*L_l1_y2p;
L_l1_x2 = L_l1_x1p; L_l1_x1 = L_x; L_l1_y2 = L_l1_y1p; L_l1_y1 = L_low_s1;

// L_LP L_Stage 2 L_para L_LOW
L_l2_x1p = L_l2_x1; L_l2_x2p = L_l2_x2; L_l2_y1p = L_l2_y1; L_l2_y2p = L_l2_y2;
L_low_raw = L_lp_b0_l*L_low_s1 + L_lp_b1_l*L_l2_x1p + L_lp_b2_l*L_l2_x2p - L_lp_a1_l*L_l2_y1p - L_lp_a2_l*L_l2_y2p;
L_l2_x2 = L_l2_x1p; L_l2_x1 = L_low_s1; L_l2_y2 = L_l2_y1p; L_l2_y1 = L_low_raw;

// L_HP L_Stage 1 L_para L_REST
L_h1_x1p = L_h1_x1; L_h1_x2p = L_h1_x2; L_h1_y1p = L_h1_y1; L_h1_y2p = L_h1_y2;
L_rest_s1 = L_hp_b0_l*L_x + L_hp_b1_l*L_h1_x1p + L_hp_b2_l*L_h1_x2p - L_hp_a1_l*L_h1_y1p - L_hp_a2_l*L_h1_y2p;
L_h1_x2 = L_h1_x1p; L_h1_x1 = L_x; L_h1_y2 = L_h1_y1p; L_h1_y1 = L_rest_s1;

// L_HP L_Stage 2 L_para L_REST
L_h2_x1p = L_h2_x1; L_h2_x2p = L_h2_x2; L_h2_y1p = L_h2_y1; L_h2_y2p = L_h2_y2;
L_rest = L_hp_b0_l*L_rest_s1 + L_hp_b1_l*L_h2_x1p + L_hp_b2_l*L_h2_x2p - L_hp_a1_l*L_h2_y1p - L_hp_a2_l*L_h2_y2p;
L_h2_x2 = L_h2_x1p; L_h2_x1 = L_rest_s1; L_h2_y2 = L_h2_y1p; L_h2_y1 = L_rest;

// ===== COMPENSACIÓN L_ALL-L_PASS L_para L_LOW =====
// L_Aplicamos L_un L_all-L_pass L_LP+L_HP @ L_hiF L_a L_la señal L_LOW L_para L_igualar L_el L_delay

// L_All-L_pass L_LP L_stage 1 L_sobre L_low_raw
L_ap_low_lp1_x1p = L_ap_low_lp1_x1; L_ap_low_lp1_x2p = L_ap_low_lp1_x2;
L_ap_low_lp1_y1p = L_ap_low_lp1_y1; L_ap_low_lp1_y2p = L_ap_low_lp1_y2;
L_ap_low_lp_s1 = L_lp_b0_h*L_low_raw + L_lp_b1_h*L_ap_low_lp1_x1p + L_lp_b2_h*L_ap_low_lp1_x2p
               - L_lp_a1_h*L_ap_low_lp1_y1p - L_lp_a2_h*L_ap_low_lp1_y2p;
L_ap_low_lp1_x2 = L_ap_low_lp1_x1p; L_ap_low_lp1_x1 = L_low_raw;
L_ap_low_lp1_y2 = L_ap_low_lp1_y1p; L_ap_low_lp1_y1 = L_ap_low_lp_s1;

// L_All-L_pass L_LP L_stage 2
L_ap_low_lp2_x1p = L_ap_low_lp2_x1; L_ap_low_lp2_x2p = L_ap_low_lp2_x2;
L_ap_low_lp2_y1p = L_ap_low_lp2_y1; L_ap_low_lp2_y2p = L_ap_low_lp2_y2;
L_ap_low_lp = L_lp_b0_h*L_ap_low_lp_s1 + L_lp_b1_h*L_ap_low_lp2_x1p + L_lp_b2_h*L_ap_low_lp2_x2p
            - L_lp_a1_h*L_ap_low_lp2_y1p - L_lp_a2_h*L_ap_low_lp2_y2p;
L_ap_low_lp2_x2 = L_ap_low_lp2_x1p; L_ap_low_lp2_x1 = L_ap_low_lp_s1;
L_ap_low_lp2_y2 = L_ap_low_lp2_y1p; L_ap_low_lp2_y1 = L_ap_low_lp;

// L_All-L_pass L_HP L_stage 1 L_sobre L_low_raw
L_ap_low_hp1_x1p = L_ap_low_hp1_x1; L_ap_low_hp1_x2p = L_ap_low_hp1_x2;
L_ap_low_hp1_y1p = L_ap_low_hp1_y1; L_ap_low_hp1_y2p = L_ap_low_hp1_y2;
L_ap_low_hp_s1 = L_hp_b0_h*L_low_raw + L_hp_b1_h*L_ap_low_hp1_x1p + L_hp_b2_h*L_ap_low_hp1_x2p
               - L_hp_a1_h*L_ap_low_hp1_y1p - L_hp_a2_h*L_ap_low_hp1_y2p;
L_ap_low_hp1_x2 = L_ap_low_hp1_x1p; L_ap_low_hp1_x1 = L_low_raw;
L_ap_low_hp1_y2 = L_ap_low_hp1_y1p; L_ap_low_hp1_y1 = L_ap_low_hp_s1;

// L_All-L_pass L_HP L_stage 2
L_ap_low_hp2_x1p = L_ap_low_hp2_x1; L_ap_low_hp2_x2p = L_ap_low_hp2_x2;
L_ap_low_hp2_y1p = L_ap_low_hp2_y1; L_ap_low_hp2_y2p = L_ap_low_hp2_y2;
L_ap_low_hp = L_hp_b0_h*L_ap_low_hp_s1 + L_hp_b1_h*L_ap_low_hp2_x1p + L_hp_b2_h*L_ap_low_hp2_x2p
            - L_hp_a1_h*L_ap_low_hp2_y1p - L_hp_a2_h*L_ap_low_hp2_y2p;
L_ap_low_hp2_x2 = L_ap_low_hp2_x1p; L_ap_low_hp2_x1 = L_ap_low_hp_s1;
L_ap_low_hp2_y2 = L_ap_low_hp2_y1p; L_ap_low_hp2_y1 = L_ap_low_hp;

// L_LOW L_compensado (L_all-L_pass L_reconstruye L_la señal L_con L_el L_mismo L_delay L_que L_mid/L_high)
L_low = L_ap_low_lp + L_ap_low_hp;

// ===== L_SEGUNDO L_CORTE @ L_hiF L_sobre L_REST: L_mid (L_LP) L_y L_high (L_HP) =====

// L_LP L_Stage 1 L_para L_MID
L_m1_x1p = L_m1_x1; L_m1_x2p = L_m1_x2; L_m1_y1p = L_m1_y1; L_m1_y2p = L_m1_y2;
L_mid_s1 = L_lp_b0_h*L_rest + L_lp_b1_h*L_m1_x1p + L_lp_b2_h*L_m1_x2p - L_lp_a1_h*L_m1_y1p - L_lp_a2_h*L_m1_y2p;
L_m1_x2 = L_m1_x1p; L_m1_x1 = L_rest; L_m1_y2 = L_m1_y1p; L_m1_y1 = L_mid_s1;

// L_LP L_Stage 2 L_para L_MID
L_m2_x1p = L_m2_x1; L_m2_x2p = L_m2_x2; L_m2_y1p = L_m2_y1; L_m2_y2p = L_m2_y2;
L_mid = L_lp_b0_h*L_mid_s1 + L_lp_b1_h*L_m2_x1p + L_lp_b2_h*L_m2_x2p - L_lp_a1_h*L_m2_y1p - L_lp_a2_h*L_m2_y2p;
L_m2_x2 = L_m2_x1p; L_m2_x1 = L_mid_s1; L_m2_y2 = L_m2_y1p; L_m2_y1 = L_mid;

// L_HP L_Stage 1 L_para L_HIGH
L_u1_x1p = L_u1_x1; L_u1_x2p = L_u1_x2; L_u1_y1p = L_u1_y1; L_u1_y2p = L_u1_y2;
L_high_s1 = L_hp_b0_h*L_rest + L_hp_b1_h*L_u1_x1p + L_hp_b2_h*L_u1_x2p - L_hp_a1_h*L_u1_y1p - L_hp_a2_h*L_u1_y2p;
L_u1_x2 = L_u1_x1p; L_u1_x1 = L_rest; L_u1_y2 = L_u1_y1p; L_u1_y1 = L_high_s1;

// L_HP L_Stage 2 L_para L_HIGH
L_u2_x1p = L_u2_x1; L_u2_x2p = L_u2_x2; L_u2_y1p = L_u2_y1; L_u2_y2p = L_u2_y2;
L_high = L_hp_b0_h*L_high_s1 + L_hp_b1_h*L_u2_x1p + L_hp_b2_h*L_u2_x2p - L_hp_a1_h*L_u2_y1p - L_hp_a2_h*L_u2_y2p;
L_u2_x2 = L_u2_x1p; L_u2_x1 = L_high_s1; L_u2_y2 = L_u2_y1p; L_u2_y1 = L_high;

// ===== L_SALIDAS =====
lowL = L_low;   // L_Graves L_compensados
midL = L_mid;   // L_Medios
highL = L_high;  // L_Agudos

// === R_bindings ===
R_loF = smoothHpfFreq;
R_hiF = smoothLpfFreq;
// R_Crossover R_LR4 R_de 3 R_bandas R_con compensación R_de R_fase R_correcta
// out1: R_Low (20-250Hz)
// out2: R_Mid (250-5kHz)
// out3: R_High (5k-20kHz)
// out4: R_Suma R_de R_las 3 R_bandas (R_debe R_hacer R_null R_test R_con R_entrada)

// ===== R_DECLARACIONES =====
// R_Estados R_para R_los 8 R_biquads R_del R_crossover R_principal
// R_Low R_stage 1
// R_Low R_stage 2
// R_Rest R_HP R_stage 1
// R_Rest R_HP R_stage 2
// R_Mid R_LP R_stage 1
// R_Mid R_LP R_stage 2
// R_High R_HP R_stage 1
// R_High R_HP R_stage 2

// R_Estados R_para R_all-R_pass R_de compensación R_en R_la R_banda R_LOW
// ===== R_PROCESO =====
R_x = rTrimmed;

// R_Proteger R_frecuencias
R_sr = samplerate;
R_loF = max(10, min(R_loF, 0.45 * R_sr));
R_hiFr = max(10, min(R_hiF, 0.45 * R_sr));
R_hiF = max(R_hiFr, R_loF + 1);

// R_Constantes
TWOPI = 6.283185307179586;
R_QBW = 0.7071067811865476; // sqrt(2)/2 R_para R_Butterworth

// === R_Coeficientes R_Butterworth @ R_loF ===
R_w0_lo = TWOPI * R_loF / R_sr;
R_cos_lo = cos(R_w0_lo);
R_sin_lo = sin(R_w0_lo);
R_alpha_lo = R_sin_lo / (2 * R_QBW);
R_a0_lo = 1 + R_alpha_lo;
R_a1_lo = -2 * R_cos_lo;
R_a2_lo = 1 - R_alpha_lo;

// R_LP @ R_loF (R_normalizado)
R_lp_b0_l = ((1 - R_cos_lo) * 0.5) / R_a0_lo;
R_lp_b1_l = (1 - R_cos_lo) / R_a0_lo;
R_lp_b2_l = R_lp_b0_l;
R_lp_a1_l = R_a1_lo / R_a0_lo;
R_lp_a2_l = R_a2_lo / R_a0_lo;

// R_HP @ R_loF (R_normalizado)
R_hp_b0_l = ((1 + R_cos_lo) * 0.5) / R_a0_lo;
R_hp_b1_l = -(1 + R_cos_lo) / R_a0_lo;
R_hp_b2_l = R_hp_b0_l;
R_hp_a1_l = R_lp_a1_l;
R_hp_a2_l = R_lp_a2_l;

// === R_Coeficientes R_Butterworth @ R_hiF ===
R_w0_hi = TWOPI * R_hiF / R_sr;
R_cos_hi = cos(R_w0_hi);
R_sin_hi = sin(R_w0_hi);
R_alpha_hi = R_sin_hi / (2 * R_QBW);
R_a0_hi = 1 + R_alpha_hi;
R_a1_hi = -2 * R_cos_hi;
R_a2_hi = 1 - R_alpha_hi;

// R_LP @ R_hiF (R_normalizado)
R_lp_b0_h = ((1 - R_cos_hi) * 0.5) / R_a0_hi;
R_lp_b1_h = (1 - R_cos_hi) / R_a0_hi;
R_lp_b2_h = R_lp_b0_h;
R_lp_a1_h = R_a1_hi / R_a0_hi;
R_lp_a2_h = R_a2_hi / R_a0_hi;

// R_HP @ R_hiF (R_normalizado)
R_hp_b0_h = ((1 + R_cos_hi) * 0.5) / R_a0_hi;
R_hp_b1_h = -(1 + R_cos_hi) / R_a0_hi;
R_hp_b2_h = R_hp_b0_h;
R_hp_a1_h = R_lp_a1_h;
R_hp_a2_h = R_lp_a2_h;

// ===== R_PRIMER R_CORTE @ R_loF: R_low (R_LP) R_y R_rest (R_HP) =====

// R_LP R_Stage 1 R_para R_LOW
R_l1_x1p = R_l1_x1; R_l1_x2p = R_l1_x2; R_l1_y1p = R_l1_y1; R_l1_y2p = R_l1_y2;
R_low_s1 = R_lp_b0_l*R_x + R_lp_b1_l*R_l1_x1p + R_lp_b2_l*R_l1_x2p - R_lp_a1_l*R_l1_y1p - R_lp_a2_l*R_l1_y2p;
R_l1_x2 = R_l1_x1p; R_l1_x1 = R_x; R_l1_y2 = R_l1_y1p; R_l1_y1 = R_low_s1;

// R_LP R_Stage 2 R_para R_LOW
R_l2_x1p = R_l2_x1; R_l2_x2p = R_l2_x2; R_l2_y1p = R_l2_y1; R_l2_y2p = R_l2_y2;
R_low_raw = R_lp_b0_l*R_low_s1 + R_lp_b1_l*R_l2_x1p + R_lp_b2_l*R_l2_x2p - R_lp_a1_l*R_l2_y1p - R_lp_a2_l*R_l2_y2p;
R_l2_x2 = R_l2_x1p; R_l2_x1 = R_low_s1; R_l2_y2 = R_l2_y1p; R_l2_y1 = R_low_raw;

// R_HP R_Stage 1 R_para R_REST
R_h1_x1p = R_h1_x1; R_h1_x2p = R_h1_x2; R_h1_y1p = R_h1_y1; R_h1_y2p = R_h1_y2;
R_rest_s1 = R_hp_b0_l*R_x + R_hp_b1_l*R_h1_x1p + R_hp_b2_l*R_h1_x2p - R_hp_a1_l*R_h1_y1p - R_hp_a2_l*R_h1_y2p;
R_h1_x2 = R_h1_x1p; R_h1_x1 = R_x; R_h1_y2 = R_h1_y1p; R_h1_y1 = R_rest_s1;

// R_HP R_Stage 2 R_para R_REST
R_h2_x1p = R_h2_x1; R_h2_x2p = R_h2_x2; R_h2_y1p = R_h2_y1; R_h2_y2p = R_h2_y2;
R_rest = R_hp_b0_l*R_rest_s1 + R_hp_b1_l*R_h2_x1p + R_hp_b2_l*R_h2_x2p - R_hp_a1_l*R_h2_y1p - R_hp_a2_l*R_h2_y2p;
R_h2_x2 = R_h2_x1p; R_h2_x1 = R_rest_s1; R_h2_y2 = R_h2_y1p; R_h2_y1 = R_rest;

// ===== COMPENSACIÓN R_ALL-R_PASS R_para R_LOW =====
// R_Aplicamos R_un R_all-R_pass R_LP+R_HP @ R_hiF R_a R_la señal R_LOW R_para R_igualar R_el R_delay

// R_All-R_pass R_LP R_stage 1 R_sobre R_low_raw
R_ap_low_lp1_x1p = R_ap_low_lp1_x1; R_ap_low_lp1_x2p = R_ap_low_lp1_x2;
R_ap_low_lp1_y1p = R_ap_low_lp1_y1; R_ap_low_lp1_y2p = R_ap_low_lp1_y2;
R_ap_low_lp_s1 = R_lp_b0_h*R_low_raw + R_lp_b1_h*R_ap_low_lp1_x1p + R_lp_b2_h*R_ap_low_lp1_x2p
               - R_lp_a1_h*R_ap_low_lp1_y1p - R_lp_a2_h*R_ap_low_lp1_y2p;
R_ap_low_lp1_x2 = R_ap_low_lp1_x1p; R_ap_low_lp1_x1 = R_low_raw;
R_ap_low_lp1_y2 = R_ap_low_lp1_y1p; R_ap_low_lp1_y1 = R_ap_low_lp_s1;

// R_All-R_pass R_LP R_stage 2
R_ap_low_lp2_x1p = R_ap_low_lp2_x1; R_ap_low_lp2_x2p = R_ap_low_lp2_x2;
R_ap_low_lp2_y1p = R_ap_low_lp2_y1; R_ap_low_lp2_y2p = R_ap_low_lp2_y2;
R_ap_low_lp = R_lp_b0_h*R_ap_low_lp_s1 + R_lp_b1_h*R_ap_low_lp2_x1p + R_lp_b2_h*R_ap_low_lp2_x2p
            - R_lp_a1_h*R_ap_low_lp2_y1p - R_lp_a2_h*R_ap_low_lp2_y2p;
R_ap_low_lp2_x2 = R_ap_low_lp2_x1p; R_ap_low_lp2_x1 = R_ap_low_lp_s1;
R_ap_low_lp2_y2 = R_ap_low_lp2_y1p; R_ap_low_lp2_y1 = R_ap_low_lp;

// R_All-R_pass R_HP R_stage 1 R_sobre R_low_raw
R_ap_low_hp1_x1p = R_ap_low_hp1_x1; R_ap_low_hp1_x2p = R_ap_low_hp1_x2;
R_ap_low_hp1_y1p = R_ap_low_hp1_y1; R_ap_low_hp1_y2p = R_ap_low_hp1_y2;
R_ap_low_hp_s1 = R_hp_b0_h*R_low_raw + R_hp_b1_h*R_ap_low_hp1_x1p + R_hp_b2_h*R_ap_low_hp1_x2p
               - R_hp_a1_h*R_ap_low_hp1_y1p - R_hp_a2_h*R_ap_low_hp1_y2p;
R_ap_low_hp1_x2 = R_ap_low_hp1_x1p; R_ap_low_hp1_x1 = R_low_raw;
R_ap_low_hp1_y2 = R_ap_low_hp1_y1p; R_ap_low_hp1_y1 = R_ap_low_hp_s1;

// R_All-R_pass R_HP R_stage 2
R_ap_low_hp2_x1p = R_ap_low_hp2_x1; R_ap_low_hp2_x2p = R_ap_low_hp2_x2;
R_ap_low_hp2_y1p = R_ap_low_hp2_y1; R_ap_low_hp2_y2p = R_ap_low_hp2_y2;
R_ap_low_hp = R_hp_b0_h*R_ap_low_hp_s1 + R_hp_b1_h*R_ap_low_hp2_x1p + R_hp_b2_h*R_ap_low_hp2_x2p
            - R_hp_a1_h*R_ap_low_hp2_y1p - R_hp_a2_h*R_ap_low_hp2_y2p;
R_ap_low_hp2_x2 = R_ap_low_hp2_x1p; R_ap_low_hp2_x1 = R_ap_low_hp_s1;
R_ap_low_hp2_y2 = R_ap_low_hp2_y1p; R_ap_low_hp2_y1 = R_ap_low_hp;

// R_LOW R_compensado (R_all-R_pass R_reconstruye R_la señal R_con R_el R_mismo R_delay R_que R_mid/R_high)
R_low = R_ap_low_lp + R_ap_low_hp;

// ===== R_SEGUNDO R_CORTE @ R_hiF R_sobre R_REST: R_mid (R_LP) R_y R_high (R_HP) =====

// R_LP R_Stage 1 R_para R_MID
R_m1_x1p = R_m1_x1; R_m1_x2p = R_m1_x2; R_m1_y1p = R_m1_y1; R_m1_y2p = R_m1_y2;
R_mid_s1 = R_lp_b0_h*R_rest + R_lp_b1_h*R_m1_x1p + R_lp_b2_h*R_m1_x2p - R_lp_a1_h*R_m1_y1p - R_lp_a2_h*R_m1_y2p;
R_m1_x2 = R_m1_x1p; R_m1_x1 = R_rest; R_m1_y2 = R_m1_y1p; R_m1_y1 = R_mid_s1;

// R_LP R_Stage 2 R_para R_MID
R_m2_x1p = R_m2_x1; R_m2_x2p = R_m2_x2; R_m2_y1p = R_m2_y1; R_m2_y2p = R_m2_y2;
R_mid = R_lp_b0_h*R_mid_s1 + R_lp_b1_h*R_m2_x1p + R_lp_b2_h*R_m2_x2p - R_lp_a1_h*R_m2_y1p - R_lp_a2_h*R_m2_y2p;
R_m2_x2 = R_m2_x1p; R_m2_x1 = R_mid_s1; R_m2_y2 = R_m2_y1p; R_m2_y1 = R_mid;

// R_HP R_Stage 1 R_para R_HIGH
R_u1_x1p = R_u1_x1; R_u1_x2p = R_u1_x2; R_u1_y1p = R_u1_y1; R_u1_y2p = R_u1_y2;
R_high_s1 = R_hp_b0_h*R_rest + R_hp_b1_h*R_u1_x1p + R_hp_b2_h*R_u1_x2p - R_hp_a1_h*R_u1_y1p - R_hp_a2_h*R_u1_y2p;
R_u1_x2 = R_u1_x1p; R_u1_x1 = R_rest; R_u1_y2 = R_u1_y1p; R_u1_y1 = R_high_s1;

// R_HP R_Stage 2 R_para R_HIGH
R_u2_x1p = R_u2_x1; R_u2_x2p = R_u2_x2; R_u2_y1p = R_u2_y1; R_u2_y2p = R_u2_y2;
R_high = R_hp_b0_h*R_high_s1 + R_hp_b1_h*R_u2_x1p + R_hp_b2_h*R_u2_x2p - R_hp_a1_h*R_u2_y1p - R_hp_a2_h*R_u2_y2p;
R_u2_x2 = R_u2_x1p; R_u2_x1 = R_high_s1; R_u2_y2 = R_u2_y1p; R_u2_y1 = R_high;

// ===== R_SALIDAS =====
lowR = R_low;   // R_Graves R_compensados
midR = R_mid;   // R_Medios
highR = R_high;  // R_Agudos


// Selector de banda (0=low, 1=mid, 2=high) con suavizado (smoothedBand)
wLow = max(0, 1 - abs(smoothedBand - 0));
wMid = max(0, 1 - abs(smoothedBand - 1));
wHigh = max(0, 1 - abs(smoothedBand - 2));
wSum = max(1e-9, wLow + wMid + wHigh);
wLow /= wSum; wMid /= wSum; wHigh /= wSum;

// Banda a procesar y suma limpia para recomponer
preBandL = wLow*lowL + wMid*midL + wHigh*highL;
preBandR = wLow*lowR + wMid*midR + wHigh*highR;
sumBandsL = lowL + midL + highL;
sumBandsR = lowR + midR + highR;
bypassWhenActiveL = sumBandsL - preBandL;
bypassWhenActiveR = sumBandsR - preBandR;

// Conmutación por enable (scSm): si desactivado, banda ancha
preDistInL = mix(lTrimmed, preBandL, scSm);
preDistInR = mix(rTrimmed, preBandR, scSm);

// Allpass de compensación solo para la rama dry cuando crossover activo
// === L_AP bindings ===
L_loF = smoothHpfFreq;
L_hiF = smoothLpfFreq;
// L_All-L_pass L_LR4 L_de compensación L_para L_null L_test L_externo
// L_Aplica L_el L_mismo L_delay L_de L_grupo L_que L_el L_crossover L_LR4
// L_Para L_usar L_en L_la línea L_dry L_fuera L_del L_crossover

// Parámetros (L_deben L_coincidir L_con L_los L_del L_crossover)
// L_Estados L_para L_primer L_all-L_pass @ L_loF
// L_Estados L_para L_segundo L_all-L_pass @ L_hiF
// L_Entrada
L_x = lTrimmed;

// L_Constantes
TWOPI = 6.283185307179586;
L_QBW = 0.7071067811865476; // sqrt(2)/2 L_para L_Butterworth

// L_Proteger L_frecuencias
L_sr = samplerate;
L_loF = max(10, min(L_loF, 0.45 * L_sr));
L_hiFr = max(10, min(L_hiF, 0.45 * L_sr));
L_hiF = max(L_hiFr, L_loF + 1);

// === L_Coeficientes L_Butterworth @ L_loF ===
L_w0_lo = TWOPI * L_loF / L_sr;
L_cos_lo = cos(L_w0_lo);
L_sin_lo = sin(L_w0_lo);
L_alpha_lo = L_sin_lo / (2 * L_QBW);
L_a0_lo = 1 + L_alpha_lo;
L_a1_lo = -2 * L_cos_lo;
L_a2_lo = 1 - L_alpha_lo;

// L_LP @ L_loF (L_normalizado)
L_lp_b0_l = ((1 - L_cos_lo) * 0.5) / L_a0_lo;
L_lp_b1_l = (1 - L_cos_lo) / L_a0_lo;
L_lp_b2_l = L_lp_b0_l;
L_lp_a1_l = L_a1_lo / L_a0_lo;
L_lp_a2_l = L_a2_lo / L_a0_lo;

// L_HP @ L_loF (L_normalizado)
L_hp_b0_l = ((1 + L_cos_lo) * 0.5) / L_a0_lo;
L_hp_b1_l = -(1 + L_cos_lo) / L_a0_lo;
L_hp_b2_l = L_hp_b0_l;
L_hp_a1_l = L_lp_a1_l;
L_hp_a2_l = L_lp_a2_l;

// === L_Coeficientes L_Butterworth @ L_hiF ===
L_w0_hi = TWOPI * L_hiF / L_sr;
L_cos_hi = cos(L_w0_hi);
L_sin_hi = sin(L_w0_hi);
L_alpha_hi = L_sin_hi / (2 * L_QBW);
L_a0_hi = 1 + L_alpha_hi;
L_a1_hi = -2 * L_cos_hi;
L_a2_hi = 1 - L_alpha_hi;

// L_LP @ L_hiF (L_normalizado)
L_lp_b0_h = ((1 - L_cos_hi) * 0.5) / L_a0_hi;
L_lp_b1_h = (1 - L_cos_hi) / L_a0_hi;
L_lp_b2_h = L_lp_b0_h;
L_lp_a1_h = L_a1_hi / L_a0_hi;
L_lp_a2_h = L_a2_hi / L_a0_hi;

// L_HP @ L_hiF (L_normalizado)
L_hp_b0_h = ((1 + L_cos_hi) * 0.5) / L_a0_hi;
L_hp_b1_h = -(1 + L_cos_hi) / L_a0_hi;
L_hp_b2_h = L_hp_b0_h;
L_hp_a1_h = L_lp_a1_h;
L_hp_a2_h = L_lp_a2_h;

// === L_PRIMER L_ALL-L_PASS @ L_loF ===
// L_LP L_Stage 1
L_ap1_lp1_x1p = L_ap1_lp1_x1; L_ap1_lp1_x2p = L_ap1_lp1_x2;
L_ap1_lp1_y1p = L_ap1_lp1_y1; L_ap1_lp1_y2p = L_ap1_lp1_y2;
L_ap1_lp_s1 = L_lp_b0_l*L_x + L_lp_b1_l*L_ap1_lp1_x1p + L_lp_b2_l*L_ap1_lp1_x2p
            - L_lp_a1_l*L_ap1_lp1_y1p - L_lp_a2_l*L_ap1_lp1_y2p;
L_ap1_lp1_x2 = L_ap1_lp1_x1p; L_ap1_lp1_x1 = L_x;
L_ap1_lp1_y2 = L_ap1_lp1_y1p; L_ap1_lp1_y1 = L_ap1_lp_s1;

// L_LP L_Stage 2
L_ap1_lp2_x1p = L_ap1_lp2_x1; L_ap1_lp2_x2p = L_ap1_lp2_x2;
L_ap1_lp2_y1p = L_ap1_lp2_y1; L_ap1_lp2_y2p = L_ap1_lp2_y2;
L_ap1_lp = L_lp_b0_l*L_ap1_lp_s1 + L_lp_b1_l*L_ap1_lp2_x1p + L_lp_b2_l*L_ap1_lp2_x2p
         - L_lp_a1_l*L_ap1_lp2_y1p - L_lp_a2_l*L_ap1_lp2_y2p;
L_ap1_lp2_x2 = L_ap1_lp2_x1p; L_ap1_lp2_x1 = L_ap1_lp_s1;
L_ap1_lp2_y2 = L_ap1_lp2_y1p; L_ap1_lp2_y1 = L_ap1_lp;

// L_HP L_Stage 1
L_ap1_hp1_x1p = L_ap1_hp1_x1; L_ap1_hp1_x2p = L_ap1_hp1_x2;
L_ap1_hp1_y1p = L_ap1_hp1_y1; L_ap1_hp1_y2p = L_ap1_hp1_y2;
L_ap1_hp_s1 = L_hp_b0_l*L_x + L_hp_b1_l*L_ap1_hp1_x1p + L_hp_b2_l*L_ap1_hp1_x2p
            - L_hp_a1_l*L_ap1_hp1_y1p - L_hp_a2_l*L_ap1_hp1_y2p;
L_ap1_hp1_x2 = L_ap1_hp1_x1p; L_ap1_hp1_x1 = L_x;
L_ap1_hp1_y2 = L_ap1_hp1_y1p; L_ap1_hp1_y1 = L_ap1_hp_s1;

// L_HP L_Stage 2
L_ap1_hp2_x1p = L_ap1_hp2_x1; L_ap1_hp2_x2p = L_ap1_hp2_x2;
L_ap1_hp2_y1p = L_ap1_hp2_y1; L_ap1_hp2_y2p = L_ap1_hp2_y2;
L_ap1_hp = L_hp_b0_l*L_ap1_hp_s1 + L_hp_b1_l*L_ap1_hp2_x1p + L_hp_b2_l*L_ap1_hp2_x2p
         - L_hp_a1_l*L_ap1_hp2_y1p - L_hp_a2_l*L_ap1_hp2_y2p;
L_ap1_hp2_x2 = L_ap1_hp2_x1p; L_ap1_hp2_x1 = L_ap1_hp_s1;
L_ap1_hp2_y2 = L_ap1_hp2_y1p; L_ap1_hp2_y1 = L_ap1_hp;

// L_Reconstruir L_primer L_all-L_pass
L_stage1_out = L_ap1_lp + L_ap1_hp;

// === L_SEGUNDO L_ALL-L_PASS @ L_hiF ===
// L_LP L_Stage 1
L_ap2_lp1_x1p = L_ap2_lp1_x1; L_ap2_lp1_x2p = L_ap2_lp1_x2;
L_ap2_lp1_y1p = L_ap2_lp1_y1; L_ap2_lp1_y2p = L_ap2_lp1_y2;
L_ap2_lp_s1 = L_lp_b0_h*L_stage1_out + L_lp_b1_h*L_ap2_lp1_x1p + L_lp_b2_h*L_ap2_lp1_x2p
            - L_lp_a1_h*L_ap2_lp1_y1p - L_lp_a2_h*L_ap2_lp1_y2p;
L_ap2_lp1_x2 = L_ap2_lp1_x1p; L_ap2_lp1_x1 = L_stage1_out;
L_ap2_lp1_y2 = L_ap2_lp1_y1p; L_ap2_lp1_y1 = L_ap2_lp_s1;

// L_LP L_Stage 2
L_ap2_lp2_x1p = L_ap2_lp2_x1; L_ap2_lp2_x2p = L_ap2_lp2_x2;
L_ap2_lp2_y1p = L_ap2_lp2_y1; L_ap2_lp2_y2p = L_ap2_lp2_y2;
L_ap2_lp = L_lp_b0_h*L_ap2_lp_s1 + L_lp_b1_h*L_ap2_lp2_x1p + L_lp_b2_h*L_ap2_lp2_x2p
         - L_lp_a1_h*L_ap2_lp2_y1p - L_lp_a2_h*L_ap2_lp2_y2p;
L_ap2_lp2_x2 = L_ap2_lp2_x1p; L_ap2_lp2_x1 = L_ap2_lp_s1;
L_ap2_lp2_y2 = L_ap2_lp2_y1p; L_ap2_lp2_y1 = L_ap2_lp;

// L_HP L_Stage 1
L_ap2_hp1_x1p = L_ap2_hp1_x1; L_ap2_hp1_x2p = L_ap2_hp1_x2;
L_ap2_hp1_y1p = L_ap2_hp1_y1; L_ap2_hp1_y2p = L_ap2_hp1_y2;
L_ap2_hp_s1 = L_hp_b0_h*L_stage1_out + L_hp_b1_h*L_ap2_hp1_x1p + L_hp_b2_h*L_ap2_hp1_x2p
            - L_hp_a1_h*L_ap2_hp1_y1p - L_hp_a2_h*L_ap2_hp1_y2p;
L_ap2_hp1_x2 = L_ap2_hp1_x1p; L_ap2_hp1_x1 = L_stage1_out;
L_ap2_hp1_y2 = L_ap2_hp1_y1p; L_ap2_hp1_y1 = L_ap2_hp_s1;

// L_HP L_Stage 2
L_ap2_hp2_x1p = L_ap2_hp2_x1; L_ap2_hp2_x2p = L_ap2_hp2_x2;
L_ap2_hp2_y1p = L_ap2_hp2_y1; L_ap2_hp2_y2p = L_ap2_hp2_y2;
L_ap2_hp = L_hp_b0_h*L_ap2_hp_s1 + L_hp_b1_h*L_ap2_hp2_x1p + L_hp_b2_h*L_ap2_hp2_x2p
         - L_hp_a1_h*L_ap2_hp2_y1p - L_hp_a2_h*L_ap2_hp2_y2p;
L_ap2_hp2_x2 = L_ap2_hp2_x1p; L_ap2_hp2_x1 = L_ap2_hp_s1;
L_ap2_hp2_y2 = L_ap2_hp2_y1p; L_ap2_hp2_y1 = L_ap2_hp;

// L_Salida: señal L_con L_el L_mismo L_delay L_que L_el L_crossover L_LR4
dryCompL = L_ap2_lp + L_ap2_hp;
// === R_AP bindings ===
R_loF = smoothHpfFreq;
R_hiF = smoothLpfFreq;
// R_All-R_pass R_LR4 R_de compensación R_para R_null R_test R_externo
// R_Aplica R_el R_mismo R_delay R_de R_grupo R_que R_el R_crossover R_LR4
// R_Para R_usar R_en R_la línea R_dry R_fuera R_del R_crossover

// Parámetros (R_deben R_coincidir R_con R_los R_del R_crossover)
// R_Estados R_para R_primer R_all-R_pass @ R_loF
// R_Estados R_para R_segundo R_all-R_pass @ R_hiF
// R_Entrada
R_x = rTrimmed;

// R_Constantes
TWOPI = 6.283185307179586;
R_QBW = 0.7071067811865476; // sqrt(2)/2 R_para R_Butterworth

// R_Proteger R_frecuencias
R_sr = samplerate;
R_loF = max(10, min(R_loF, 0.45 * R_sr));
R_hiFr = max(10, min(R_hiF, 0.45 * R_sr));
R_hiF = max(R_hiFr, R_loF + 1);

// === R_Coeficientes R_Butterworth @ R_loF ===
R_w0_lo = TWOPI * R_loF / R_sr;
R_cos_lo = cos(R_w0_lo);
R_sin_lo = sin(R_w0_lo);
R_alpha_lo = R_sin_lo / (2 * R_QBW);
R_a0_lo = 1 + R_alpha_lo;
R_a1_lo = -2 * R_cos_lo;
R_a2_lo = 1 - R_alpha_lo;

// R_LP @ R_loF (R_normalizado)
R_lp_b0_l = ((1 - R_cos_lo) * 0.5) / R_a0_lo;
R_lp_b1_l = (1 - R_cos_lo) / R_a0_lo;
R_lp_b2_l = R_lp_b0_l;
R_lp_a1_l = R_a1_lo / R_a0_lo;
R_lp_a2_l = R_a2_lo / R_a0_lo;

// R_HP @ R_loF (R_normalizado)
R_hp_b0_l = ((1 + R_cos_lo) * 0.5) / R_a0_lo;
R_hp_b1_l = -(1 + R_cos_lo) / R_a0_lo;
R_hp_b2_l = R_hp_b0_l;
R_hp_a1_l = R_lp_a1_l;
R_hp_a2_l = R_lp_a2_l;

// === R_Coeficientes R_Butterworth @ R_hiF ===
R_w0_hi = TWOPI * R_hiF / R_sr;
R_cos_hi = cos(R_w0_hi);
R_sin_hi = sin(R_w0_hi);
R_alpha_hi = R_sin_hi / (2 * R_QBW);
R_a0_hi = 1 + R_alpha_hi;
R_a1_hi = -2 * R_cos_hi;
R_a2_hi = 1 - R_alpha_hi;

// R_LP @ R_hiF (R_normalizado)
R_lp_b0_h = ((1 - R_cos_hi) * 0.5) / R_a0_hi;
R_lp_b1_h = (1 - R_cos_hi) / R_a0_hi;
R_lp_b2_h = R_lp_b0_h;
R_lp_a1_h = R_a1_hi / R_a0_hi;
R_lp_a2_h = R_a2_hi / R_a0_hi;

// R_HP @ R_hiF (R_normalizado)
R_hp_b0_h = ((1 + R_cos_hi) * 0.5) / R_a0_hi;
R_hp_b1_h = -(1 + R_cos_hi) / R_a0_hi;
R_hp_b2_h = R_hp_b0_h;
R_hp_a1_h = R_lp_a1_h;
R_hp_a2_h = R_lp_a2_h;

// === R_PRIMER R_ALL-R_PASS @ R_loF ===
// R_LP R_Stage 1
R_ap1_lp1_x1p = R_ap1_lp1_x1; R_ap1_lp1_x2p = R_ap1_lp1_x2;
R_ap1_lp1_y1p = R_ap1_lp1_y1; R_ap1_lp1_y2p = R_ap1_lp1_y2;
R_ap1_lp_s1 = R_lp_b0_l*R_x + R_lp_b1_l*R_ap1_lp1_x1p + R_lp_b2_l*R_ap1_lp1_x2p
            - R_lp_a1_l*R_ap1_lp1_y1p - R_lp_a2_l*R_ap1_lp1_y2p;
R_ap1_lp1_x2 = R_ap1_lp1_x1p; R_ap1_lp1_x1 = R_x;
R_ap1_lp1_y2 = R_ap1_lp1_y1p; R_ap1_lp1_y1 = R_ap1_lp_s1;

// R_LP R_Stage 2
R_ap1_lp2_x1p = R_ap1_lp2_x1; R_ap1_lp2_x2p = R_ap1_lp2_x2;
R_ap1_lp2_y1p = R_ap1_lp2_y1; R_ap1_lp2_y2p = R_ap1_lp2_y2;
R_ap1_lp = R_lp_b0_l*R_ap1_lp_s1 + R_lp_b1_l*R_ap1_lp2_x1p + R_lp_b2_l*R_ap1_lp2_x2p
         - R_lp_a1_l*R_ap1_lp2_y1p - R_lp_a2_l*R_ap1_lp2_y2p;
R_ap1_lp2_x2 = R_ap1_lp2_x1p; R_ap1_lp2_x1 = R_ap1_lp_s1;
R_ap1_lp2_y2 = R_ap1_lp2_y1p; R_ap1_lp2_y1 = R_ap1_lp;

// R_HP R_Stage 1
R_ap1_hp1_x1p = R_ap1_hp1_x1; R_ap1_hp1_x2p = R_ap1_hp1_x2;
R_ap1_hp1_y1p = R_ap1_hp1_y1; R_ap1_hp1_y2p = R_ap1_hp1_y2;
R_ap1_hp_s1 = R_hp_b0_l*R_x + R_hp_b1_l*R_ap1_hp1_x1p + R_hp_b2_l*R_ap1_hp1_x2p
            - R_hp_a1_l*R_ap1_hp1_y1p - R_hp_a2_l*R_ap1_hp1_y2p;
R_ap1_hp1_x2 = R_ap1_hp1_x1p; R_ap1_hp1_x1 = R_x;
R_ap1_hp1_y2 = R_ap1_hp1_y1p; R_ap1_hp1_y1 = R_ap1_hp_s1;

// R_HP R_Stage 2
R_ap1_hp2_x1p = R_ap1_hp2_x1; R_ap1_hp2_x2p = R_ap1_hp2_x2;
R_ap1_hp2_y1p = R_ap1_hp2_y1; R_ap1_hp2_y2p = R_ap1_hp2_y2;
R_ap1_hp = R_hp_b0_l*R_ap1_hp_s1 + R_hp_b1_l*R_ap1_hp2_x1p + R_hp_b2_l*R_ap1_hp2_x2p
         - R_hp_a1_l*R_ap1_hp2_y1p - R_hp_a2_l*R_ap1_hp2_y2p;
R_ap1_hp2_x2 = R_ap1_hp2_x1p; R_ap1_hp2_x1 = R_ap1_hp_s1;
R_ap1_hp2_y2 = R_ap1_hp2_y1p; R_ap1_hp2_y1 = R_ap1_hp;

// R_Reconstruir R_primer R_all-R_pass
R_stage1_out = R_ap1_lp + R_ap1_hp;

// === R_SEGUNDO R_ALL-R_PASS @ R_hiF ===
// R_LP R_Stage 1
R_ap2_lp1_x1p = R_ap2_lp1_x1; R_ap2_lp1_x2p = R_ap2_lp1_x2;
R_ap2_lp1_y1p = R_ap2_lp1_y1; R_ap2_lp1_y2p = R_ap2_lp1_y2;
R_ap2_lp_s1 = R_lp_b0_h*R_stage1_out + R_lp_b1_h*R_ap2_lp1_x1p + R_lp_b2_h*R_ap2_lp1_x2p
            - R_lp_a1_h*R_ap2_lp1_y1p - R_lp_a2_h*R_ap2_lp1_y2p;
R_ap2_lp1_x2 = R_ap2_lp1_x1p; R_ap2_lp1_x1 = R_stage1_out;
R_ap2_lp1_y2 = R_ap2_lp1_y1p; R_ap2_lp1_y1 = R_ap2_lp_s1;

// R_LP R_Stage 2
R_ap2_lp2_x1p = R_ap2_lp2_x1; R_ap2_lp2_x2p = R_ap2_lp2_x2;
R_ap2_lp2_y1p = R_ap2_lp2_y1; R_ap2_lp2_y2p = R_ap2_lp2_y2;
R_ap2_lp = R_lp_b0_h*R_ap2_lp_s1 + R_lp_b1_h*R_ap2_lp2_x1p + R_lp_b2_h*R_ap2_lp2_x2p
         - R_lp_a1_h*R_ap2_lp2_y1p - R_lp_a2_h*R_ap2_lp2_y2p;
R_ap2_lp2_x2 = R_ap2_lp2_x1p; R_ap2_lp2_x1 = R_ap2_lp_s1;
R_ap2_lp2_y2 = R_ap2_lp2_y1p; R_ap2_lp2_y1 = R_ap2_lp;

// R_HP R_Stage 1
R_ap2_hp1_x1p = R_ap2_hp1_x1; R_ap2_hp1_x2p = R_ap2_hp1_x2;
R_ap2_hp1_y1p = R_ap2_hp1_y1; R_ap2_hp1_y2p = R_ap2_hp1_y2;
R_ap2_hp_s1 = R_hp_b0_h*R_stage1_out + R_hp_b1_h*R_ap2_hp1_x1p + R_hp_b2_h*R_ap2_hp1_x2p
            - R_hp_a1_h*R_ap2_hp1_y1p - R_hp_a2_h*R_ap2_hp1_y2p;
R_ap2_hp1_x2 = R_ap2_hp1_x1p; R_ap2_hp1_x1 = R_stage1_out;
R_ap2_hp1_y2 = R_ap2_hp1_y1p; R_ap2_hp1_y1 = R_ap2_hp_s1;

// R_HP R_Stage 2
R_ap2_hp2_x1p = R_ap2_hp2_x1; R_ap2_hp2_x2p = R_ap2_hp2_x2;
R_ap2_hp2_y1p = R_ap2_hp2_y1; R_ap2_hp2_y2p = R_ap2_hp2_y2;
R_ap2_hp = R_hp_b0_h*R_ap2_hp_s1 + R_hp_b1_h*R_ap2_hp2_x1p + R_hp_b2_h*R_ap2_hp2_x2p
         - R_hp_a1_h*R_ap2_hp2_y1p - R_hp_a2_h*R_ap2_hp2_y2p;
R_ap2_hp2_x2 = R_ap2_hp2_x1p; R_ap2_hp2_x1 = R_ap2_hp_s1;
R_ap2_hp2_y2 = R_ap2_hp2_y1p; R_ap2_hp2_y1 = R_ap2_hp;

// R_Salida: señal R_con R_el R_mismo R_delay R_que R_el R_crossover R_LR4
dryCompR = R_ap2_lp + R_ap2_hp;
dryL = mix(lIn, dryCompL, scSm);
dryR = mix(rIn, dryCompR, scSm);

// Entrada al bloque de TILT
lLs = preDistInL;
rLs = preDistInR;

// Mapeo para TILT: usar la señal seleccionada por el crossover
lFiltered = preDistInL;
rFiltered = preDistInR;

// -----------------------------------------------------------------------------
// FILTRO TILT PRE-DISTORSIÓN
// -----------------------------------------------------------------------------
fc = 1000.0;     // 1 kHz como pivote del tilt
// q ya no se usa en la versión RBJ del tilt (S=1 internamente)

// Cálculo de coeficientes para Tilt (invertido para UI intuitiva)
//tiltGain = dbtoa(-tiltDb);
//omega = (fc * twopi) / samplerate;
//sn = sin(omega);
//cs = cos(omega);
//A = sqrt(tiltGain);
//beta = sqrt((A * A + 1) / q - (A - 1) * (A - 1));

// RBJ cookbook prep (tilt = LS(-G) + HS(+G))
omega = (fc * twopi) / samplerate;
sn = sin(omega);
cs = cos(omega);

// Ganancias complementarias en dB
Gls = -tiltDb;               // Low-shelf: -G
Ghs =  tiltDb;               // High-shelf: +G

// A = 10^(G/40)
Als = sqrt(dbtoa(Gls));
Ahs = sqrt(dbtoa(Ghs));

// Slope RBJ (S=1 es canónico y estable)
S  = 1.0;

// alpha para shelves (RBJ)
alphaLs = 0.5 * sn * sqrt((Als + 1/Als) * (1/S - 1) + 2);
alphaHs = 0.5 * sn * sqrt((Ahs + 1/Ahs) * (1/S - 1) + 2);

// raíces de A (se usan en los términos 2*sqrt(A)*alpha)
sqrtAls = sqrt(Als);
sqrtAhs = sqrt(Ahs);

// Coeficientes Low Shelf
//b0Ls = 1 / ((A + 1) + (A - 1) * cs + beta * sn);
//a0Ls = A * ((A + 1) - (A - 1) * cs + beta * sn) * b0Ls;
//a1Ls = 2 * A * ((A - 1) - (A + 1) * cs) * b0Ls;
//a2Ls = A * ((A + 1) - (A - 1) * cs - beta * sn) * b0Ls;
//b1Ls = -2 * ((A - 1) + (A + 1) * cs) * b0Ls;
//b2Ls = ((A + 1) + (A - 1) * cs - beta * sn) * b0Ls;

// RBJ Low-Shelf (normalizado a a0)
b0_ls =  Als * ((Als + 1) - (Als - 1) * cs + 2 * sqrtAls * alphaLs);
b1_ls = 2*Als * ((Als - 1) - (Als + 1) * cs);
b2_ls =  Als * ((Als + 1) - (Als - 1) * cs - 2 * sqrtAls * alphaLs);

a0_ls =        (Als + 1) + (Als - 1) * cs + 2 * sqrtAls * alphaLs;
a1_ls =   -2 * ((Als - 1) + (Als + 1) * cs);
a2_ls =        (Als + 1) + (Als - 1) * cs - 2 * sqrtAls * alphaLs;

// Normalización
inv_a0_ls = 1 / a0_ls;
a0Ls = b0_ls * inv_a0_ls;
a1Ls = b1_ls * inv_a0_ls;
a2Ls = b2_ls * inv_a0_ls;
b1Ls = a1_ls * inv_a0_ls;
b2Ls = a2_ls * inv_a0_ls;

// Aplicar Low Shelf
//lLs = a0Ls * lFiltered + a1Ls * tiltL2 + a2Ls * tiltL1 - b1Ls * tiltL4 - b2Ls * tiltL3;
//tiltL1 = tiltL2;
//tiltL2 = lFiltered;
//tiltL3 = tiltL4;
//tiltL4 = lLs;

//rLs = a0Ls * rFiltered + a1Ls * tiltR2 + a2Ls * tiltR1 - b1Ls * tiltR4 - b2Ls * tiltR3;
//tiltR1 = tiltR2;
//tiltR2 = rFiltered;
//tiltR3 = tiltR4;
//tiltR4 = rLs;

// Aplicar Low Shelf
lLs = a0Ls * lFiltered + a1Ls * tiltLsL2 + a2Ls * tiltLsL1 - b1Ls * tiltLsL4 - b2Ls * tiltLsL3;
tiltLsL1 = tiltLsL2;
tiltLsL2 = lFiltered;
tiltLsL3 = tiltLsL4;
tiltLsL4 = lLs;

rLs = a0Ls * rFiltered + a1Ls * tiltLsR2 + a2Ls * tiltLsR1 - b1Ls * tiltLsR4 - b2Ls * tiltLsR3;
tiltLsR1 = tiltLsR2;
tiltLsR2 = rFiltered;
tiltLsR3 = tiltLsR4;
tiltLsR4 = rLs;

// Coeficientes High Shelf
//aInv = sqrt(1/tiltGain);
//betaHs = sqrt((aInv * aInv + 1) / q - (aInv - 1) * (aInv - 1));
//b0Hs = 1 / ((aInv + 1) - (aInv - 1) * cs + betaHs * sn);
//a0Hs = aInv * ((aInv + 1) + (aInv - 1) * cs + betaHs * sn) * b0Hs;
//a1Hs = -2 * aInv * ((aInv - 1) + (aInv + 1) * cs) * b0Hs;
//a2Hs = aInv * ((aInv + 1) + (aInv - 1) * cs - betaHs * sn) * b0Hs;
//b1Hs = 2 * ((aInv - 1) - (aInv + 1) * cs) * b0Hs;
//b2Hs = ((aInv + 1) - (aInv - 1) * cs - betaHs * sn) * b0Hs;

// RBJ High-Shelf (normalizado a a0)
b0_hs =  Ahs * ((Ahs + 1) + (Ahs - 1) * cs + 2 * sqrtAhs * alphaHs);
b1_hs = -2*Ahs * ((Ahs - 1) + (Ahs + 1) * cs);
b2_hs =  Ahs * ((Ahs + 1) + (Ahs - 1) * cs - 2 * sqrtAhs * alphaHs);

a0_hs =        (Ahs + 1) - (Ahs - 1) * cs + 2 * sqrtAhs * alphaHs;
a1_hs =    2 * ((Ahs - 1) - (Ahs + 1) * cs);
a2_hs =        (Ahs + 1) - (Ahs - 1) * cs - 2 * sqrtAhs * alphaHs;

// Normalización
inv_a0_hs = 1 / a0_hs;
a0Hs = b0_hs * inv_a0_hs;
a1Hs = b1_hs * inv_a0_hs;
a2Hs = b2_hs * inv_a0_hs;
b1Hs = a1_hs * inv_a0_hs;
b2Hs = a2_hs * inv_a0_hs;

//lTilt = a0Hs * lLs + a1Hs * tiltL2 + a2Hs * tiltL1 - b1Hs * tiltL4 - b2Hs * tiltL3;
//rTilt = a0Hs * rLs + a1Hs * tiltR2 + a2Hs * tiltR1 - b1Hs * tiltR4 - b2Hs * tiltR3;

lTiltRaw = a0Hs * lLs + a1Hs * tiltHsL2 + a2Hs * tiltHsL1 - b1Hs * tiltHsL4 - b2Hs * tiltHsL3;
tiltHsL1 = tiltHsL2;
tiltHsL2 = lLs;
tiltHsL3 = tiltHsL4;
tiltHsL4 = lTiltRaw;

rTiltRaw = a0Hs * rLs + a1Hs * tiltHsR2 + a2Hs * tiltHsR1 - b1Hs * tiltHsR4 - b2Hs * tiltHsR3;
tiltHsR1 = tiltHsR2;
tiltHsR2 = rLs;
tiltHsR3 = tiltHsR4;
tiltHsR4 = rTiltRaw;

// Salida del bloque TILT (sin normalización aún)
//lTilt = lTiltRaw;
//rTilt = rTiltRaw;

// Normalización en el pivote (fc)
cosw = cs;           // ya calculados arriba
sinw = sn;
cos2 = (cs*cs - sn*sn);
sin2 = (2*sn*cs);

// Magnitud LS en fc
nr_ls = a0Ls + a1Ls*cosw + a2Ls*cos2;
ni_ls = -(a1Ls*sinw + a2Ls*sin2);
dr_ls = 1 + b1Ls*cosw + b2Ls*cos2;
di_ls = -(b1Ls*sinw + b2Ls*sin2);
mag2_ls = (nr_ls*nr_ls + ni_ls*ni_ls) / max(1e-12, (dr_ls*dr_ls + di_ls*di_ls));
mag_ls = sqrt(mag2_ls);

// Magnitud HS en fc
nr_hs = a0Hs + a1Hs*cosw + a2Hs*cos2;
ni_hs = -(a1Hs*sinw + a2Hs*sin2);
dr_hs = 1 + b1Hs*cosw + b2Hs*cos2;
di_hs = -(b1Hs*sinw + b2Hs*sin2);
mag2_hs = (nr_hs*nr_hs + ni_hs*ni_hs) / max(1e-12, (dr_hs*dr_hs + di_hs*di_hs));
mag_hs = sqrt(mag2_hs);

// Ganancia de normalización
gPivot = 1 / max(1e-9, mag_ls * mag_hs);

// Salida normalizada
lTilt = lTiltRaw * gPivot;
rTilt = rTiltRaw * gPivot;

// -----------------------------------------------------------------------------
// PROCESAMIENTO DE DISTORSIÓN CON MORPHING
// -----------------------------------------------------------------------------

// Ejecutar TODOS los algoritmos con implementación consistente de DC
softL, softR = softclip(lTilt, rTilt, drive, dc, ceiling);
sigmL, sigmR = sigmoid(lTilt, rTilt, drive, dc, ceiling);
rectL, rectR = rectF(lTilt, rTilt, drive, dc, ceiling);
fuzz1L, fuzz1R = fuzzExp1(lTilt, rTilt, drive, dc, ceiling);
tanhL, tanhR = tangenteHiperbolica(lTilt, rTilt, drive, dc, ceiling);
recthL, recthR = rectH(lTilt, rTilt, drive, dc, ceiling);
atanL, atanR = arctangent(lTilt, rTilt, drive, dc, ceiling);
hardL, hardR = hardClip(lTilt, rTilt, drive, dc, ceiling);

// Sistema de morphing continuo
mode = smoothedMode;  // Usar el modo suavizado

// Calcular pesos (ahora solo 8 algoritmos)
w0 = max(0, 1 - abs(mode - 0));      // Softclip
w1 = max(0, 1 - abs(mode - 1));      // Sigmoid
w2 = max(0, 1 - abs(mode - 2));      // RectF
w3 = max(0, 1 - abs(mode - 3));      // Fuzz1
w4 = max(0, 1 - abs(mode - 4));      // TanH
w5 = max(0, 1 - abs(mode - 5));      // RectH
w6 = max(0, 1 - abs(mode - 6));      // Arctangent
w7 = max(0, 1 - abs(mode - 7));      // HardClip

// Normalizar pesos
sumWeights = w0 + w1 + w2 + w3 + w4 + w5 + w6 + w7 + 0.0001;
w0 /= sumWeights; w1 /= sumWeights; w2 /= sumWeights; w3 /= sumWeights;
w4 /= sumWeights; w5 /= sumWeights; w6 /= sumWeights; w7 /= sumWeights;

// Mezclar algoritmos
distL = softL * w0 + sigmL * w1 + rectL * w2 + fuzz1L * w3 +
        tanhL * w4 + recthL * w5 + atanL * w6 + hardL * w7;

distR = softR * w0 + sigmR * w1 + rectR * w2 + fuzz1R * w3 +
        tanhR * w4 + recthR * w5 + atanR * w6 + hardR * w7;

// DC Blocker
processedL = dcblock(distL);
processedR = dcblock(distR);

// -----------------------------------------------------------------------------
// BIT CRUSHER Y DOWNSAMPLING OPCIONAL (ANTES DEL DRY/WET)
// -----------------------------------------------------------------------------
// Bit Crusher
bitL, bitR = bitCrusher(processedL, processedR, bits);
bcL = dcblock(bitL);
bcR = dcblock(bitR);

withBitCrusherL = mix(processedL, bcL, bitson);
withBitCrusherR = mix(processedR, bcR, bitson);

// Downsampling con phasor y latch
// Calcular frecuencia del decimador basada en el parámetro
// Convertir el parámetro (0-99) a factor de decimación entero (1-100)
deciFactor = max(1, floor(hDownsample + 1));
deciFreq   = samplerate / deciFactor;   // 1 latch por cada N muestras

// Edge de activación (reset de fase al pasar de OFF→ON)
enableNow  = downsampleOn > 0.5;
enableEdge = enableNow > dsEnablePrev;   // flanco de subida
dsEnablePrev = enableNow;

// Phasor manual 0..1 con reset en el flanco de activación
inc = 1 / deciFactor;                   // equivalente a deciFreq/samplerate, más claro
dsPhase = enableEdge ? 0 : (dsPhase + inc);
dsPhase = dsPhase - floor(dsPhase);

// Disparo robusto: en el wrap-around (fase actual < fase anterior) o si N==1
dsEdgeWrap = dsPhase < dsTrigPrev;      // usa dsTrigPrev como "fase previa"
dsEdge = (enableEdge + dsEdgeWrap + (deciFactor == 1)) > 0.5;
dsTrigPrev = dsPhase;

// Latch SOLO en el flanco
dsHeldL = latch(withBitCrusherL, dsEdge);
dsHeldR = latch(withBitCrusherR, dsEdge);

// Aplicar downsampling
wetFinalL = mix(withBitCrusherL, dsHeldL, downsampleOn);
wetFinalR = mix(withBitCrusherR, dsHeldR, downsampleOn);

// -----------------------------------------------------------------------------
// OUTPUT MAKEUP (SOLO A LA SEÑAL WET)
// -----------------------------------------------------------------------------
// Aplicar makeup gain ANTES del dry/wet para que solo afecte a la señal procesada
//wetWithMakeupL = wetFinalL * outputMakeupLinear + bypassWhenActiveL;
//wetWithMakeupR = wetFinalR * outputMakeupLinear + bypassWhenActiveR;
wetWithMakeupL = (wetFinalL * outputMakeupLinear) + (bypassWhenActiveL * scSm);
wetWithMakeupR = (wetFinalR * outputMakeupLinear) + (bypassWhenActiveR * scSm);

// -----------------------------------------------------------------------------
// MEZCLA DRY/WET
// -----------------------------------------------------------------------------
// Dry = señal original sin procesar (pre-trim, pre-filtros)
// Wet = señal completamente procesada (trim + filtros + tilt + distorsión + efectos + makeup)
// Parámetro drywet: 0 = solo dry, 1 = solo wet
mixedL = mix(dryL, wetWithMakeupL, drywet);
mixedR = mix(dryR, wetWithMakeupR, drywet);

// -----------------------------------------------------------------------------
// SALIDA FINAL CON BYPASS
// -----------------------------------------------------------------------------
// Ya no aplicamos makeup aquí porque ya está en la señal wet
finalL = mixedL;
finalR = mixedR;

// DC Blocker final antes de la salida
finalDcBlockedL = dcblock(finalL);
finalDcBlockedR = dcblock(finalR);

// Salidas principales
out1 = mix(lIn, finalDcBlockedL, bypass);
out2 = mix(rIn, finalDcBlockedR, bypass);

// Salida 3 vacía para mantener consistencia
out3 = 0;

// Salidas post Input Trim (para medidores)
out4 = lTrimmed;  // L post trim
out5 = rTrimmed;  // R post trim