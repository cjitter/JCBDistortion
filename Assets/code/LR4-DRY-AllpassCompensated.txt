// All-pass LR4 de compensación para null test externo
// Aplica el mismo delay de grupo que el crossover LR4
// Para usar en la línea dry fuera del crossover

// Parámetros (IMPORTANTE: deben coincidir con los del crossover)
Param freq_low(250, min=20, max=1000, default=250);
Param freq_high(5000, min=1000, max=20000, default=5000);

// Estados para primer all-pass @ freq_low
History ap1_lp1_x1(0), ap1_lp1_x2(0), ap1_lp1_y1(0), ap1_lp1_y2(0);
History ap1_lp2_x1(0), ap1_lp2_x2(0), ap1_lp2_y1(0), ap1_lp2_y2(0);
History ap1_hp1_x1(0), ap1_hp1_x2(0), ap1_hp1_y1(0), ap1_hp1_y2(0);
History ap1_hp2_x1(0), ap1_hp2_x2(0), ap1_hp2_y1(0), ap1_hp2_y2(0);

// Estados para segundo all-pass @ freq_high
History ap2_lp1_x1(0), ap2_lp1_x2(0), ap2_lp1_y1(0), ap2_lp1_y2(0);
History ap2_lp2_x1(0), ap2_lp2_x2(0), ap2_lp2_y1(0), ap2_lp2_y2(0);
History ap2_hp1_x1(0), ap2_hp1_x2(0), ap2_hp1_y1(0), ap2_hp1_y2(0);
History ap2_hp2_x1(0), ap2_hp2_x2(0), ap2_hp2_y1(0), ap2_hp2_y2(0);

// Entrada
x = in1;

// Constantes
TWOPI = 6.283185307179586;
QBW = 0.7071067811865476; // sqrt(2)/2 para Butterworth

// Proteger frecuencias
sr = samplerate;
loF = max(10, min(freq_low, 0.45 * sr));
hiFr = max(10, min(freq_high, 0.45 * sr));
hiF = max(hiFr, loF + 1);

// === Coeficientes Butterworth @ freq_low ===
w0_lo = TWOPI * loF / sr;
cos_lo = cos(w0_lo);
sin_lo = sin(w0_lo);
alpha_lo = sin_lo / (2 * QBW);
a0_lo = 1 + alpha_lo;
a1_lo = -2 * cos_lo;
a2_lo = 1 - alpha_lo;

// LP @ freq_low (normalizado)
lp_b0_l = ((1 - cos_lo) * 0.5) / a0_lo;
lp_b1_l = (1 - cos_lo) / a0_lo;
lp_b2_l = lp_b0_l;
lp_a1_l = a1_lo / a0_lo;
lp_a2_l = a2_lo / a0_lo;

// HP @ freq_low (normalizado)
hp_b0_l = ((1 + cos_lo) * 0.5) / a0_lo;
hp_b1_l = -(1 + cos_lo) / a0_lo;
hp_b2_l = hp_b0_l;
hp_a1_l = lp_a1_l;
hp_a2_l = lp_a2_l;

// === Coeficientes Butterworth @ freq_high ===
w0_hi = TWOPI * hiF / sr;
cos_hi = cos(w0_hi);
sin_hi = sin(w0_hi);
alpha_hi = sin_hi / (2 * QBW);
a0_hi = 1 + alpha_hi;
a1_hi = -2 * cos_hi;
a2_hi = 1 - alpha_hi;

// LP @ freq_high (normalizado)
lp_b0_h = ((1 - cos_hi) * 0.5) / a0_hi;
lp_b1_h = (1 - cos_hi) / a0_hi;
lp_b2_h = lp_b0_h;
lp_a1_h = a1_hi / a0_hi;
lp_a2_h = a2_hi / a0_hi;

// HP @ freq_high (normalizado)
hp_b0_h = ((1 + cos_hi) * 0.5) / a0_hi;
hp_b1_h = -(1 + cos_hi) / a0_hi;
hp_b2_h = hp_b0_h;
hp_a1_h = lp_a1_h;
hp_a2_h = lp_a2_h;

// === PRIMER ALL-PASS @ freq_low ===
// LP Stage 1
ap1_lp1_x1p = ap1_lp1_x1; ap1_lp1_x2p = ap1_lp1_x2;
ap1_lp1_y1p = ap1_lp1_y1; ap1_lp1_y2p = ap1_lp1_y2;
ap1_lp_s1 = lp_b0_l*x + lp_b1_l*ap1_lp1_x1p + lp_b2_l*ap1_lp1_x2p
            - lp_a1_l*ap1_lp1_y1p - lp_a2_l*ap1_lp1_y2p;
ap1_lp1_x2 = ap1_lp1_x1p; ap1_lp1_x1 = x;
ap1_lp1_y2 = ap1_lp1_y1p; ap1_lp1_y1 = ap1_lp_s1;

// LP Stage 2
ap1_lp2_x1p = ap1_lp2_x1; ap1_lp2_x2p = ap1_lp2_x2;
ap1_lp2_y1p = ap1_lp2_y1; ap1_lp2_y2p = ap1_lp2_y2;
ap1_lp = lp_b0_l*ap1_lp_s1 + lp_b1_l*ap1_lp2_x1p + lp_b2_l*ap1_lp2_x2p
         - lp_a1_l*ap1_lp2_y1p - lp_a2_l*ap1_lp2_y2p;
ap1_lp2_x2 = ap1_lp2_x1p; ap1_lp2_x1 = ap1_lp_s1;
ap1_lp2_y2 = ap1_lp2_y1p; ap1_lp2_y1 = ap1_lp;

// HP Stage 1
ap1_hp1_x1p = ap1_hp1_x1; ap1_hp1_x2p = ap1_hp1_x2;
ap1_hp1_y1p = ap1_hp1_y1; ap1_hp1_y2p = ap1_hp1_y2;
ap1_hp_s1 = hp_b0_l*x + hp_b1_l*ap1_hp1_x1p + hp_b2_l*ap1_hp1_x2p
            - hp_a1_l*ap1_hp1_y1p - hp_a2_l*ap1_hp1_y2p;
ap1_hp1_x2 = ap1_hp1_x1p; ap1_hp1_x1 = x;
ap1_hp1_y2 = ap1_hp1_y1p; ap1_hp1_y1 = ap1_hp_s1;

// HP Stage 2
ap1_hp2_x1p = ap1_hp2_x1; ap1_hp2_x2p = ap1_hp2_x2;
ap1_hp2_y1p = ap1_hp2_y1; ap1_hp2_y2p = ap1_hp2_y2;
ap1_hp = hp_b0_l*ap1_hp_s1 + hp_b1_l*ap1_hp2_x1p + hp_b2_l*ap1_hp2_x2p
         - hp_a1_l*ap1_hp2_y1p - hp_a2_l*ap1_hp2_y2p;
ap1_hp2_x2 = ap1_hp2_x1p; ap1_hp2_x1 = ap1_hp_s1;
ap1_hp2_y2 = ap1_hp2_y1p; ap1_hp2_y1 = ap1_hp;

// Reconstruir primer all-pass
stage1_out = ap1_lp + ap1_hp;

// === SEGUNDO ALL-PASS @ freq_high ===
// LP Stage 1
ap2_lp1_x1p = ap2_lp1_x1; ap2_lp1_x2p = ap2_lp1_x2;
ap2_lp1_y1p = ap2_lp1_y1; ap2_lp1_y2p = ap2_lp1_y2;
ap2_lp_s1 = lp_b0_h*stage1_out + lp_b1_h*ap2_lp1_x1p + lp_b2_h*ap2_lp1_x2p
            - lp_a1_h*ap2_lp1_y1p - lp_a2_h*ap2_lp1_y2p;
ap2_lp1_x2 = ap2_lp1_x1p; ap2_lp1_x1 = stage1_out;
ap2_lp1_y2 = ap2_lp1_y1p; ap2_lp1_y1 = ap2_lp_s1;

// LP Stage 2
ap2_lp2_x1p = ap2_lp2_x1; ap2_lp2_x2p = ap2_lp2_x2;
ap2_lp2_y1p = ap2_lp2_y1; ap2_lp2_y2p = ap2_lp2_y2;
ap2_lp = lp_b0_h*ap2_lp_s1 + lp_b1_h*ap2_lp2_x1p + lp_b2_h*ap2_lp2_x2p
         - lp_a1_h*ap2_lp2_y1p - lp_a2_h*ap2_lp2_y2p;
ap2_lp2_x2 = ap2_lp2_x1p; ap2_lp2_x1 = ap2_lp_s1;
ap2_lp2_y2 = ap2_lp2_y1p; ap2_lp2_y1 = ap2_lp;

// HP Stage 1
ap2_hp1_x1p = ap2_hp1_x1; ap2_hp1_x2p = ap2_hp1_x2;
ap2_hp1_y1p = ap2_hp1_y1; ap2_hp1_y2p = ap2_hp1_y2;
ap2_hp_s1 = hp_b0_h*stage1_out + hp_b1_h*ap2_hp1_x1p + hp_b2_h*ap2_hp1_x2p
            - hp_a1_h*ap2_hp1_y1p - hp_a2_h*ap2_hp1_y2p;
ap2_hp1_x2 = ap2_hp1_x1p; ap2_hp1_x1 = stage1_out;
ap2_hp1_y2 = ap2_hp1_y1p; ap2_hp1_y1 = ap2_hp_s1;

// HP Stage 2
ap2_hp2_x1p = ap2_hp2_x1; ap2_hp2_x2p = ap2_hp2_x2;
ap2_hp2_y1p = ap2_hp2_y1; ap2_hp2_y2p = ap2_hp2_y2;
ap2_hp = hp_b0_h*ap2_hp_s1 + hp_b1_h*ap2_hp2_x1p + hp_b2_h*ap2_hp2_x2p
         - hp_a1_h*ap2_hp2_y1p - hp_a2_h*ap2_hp2_y2p;
ap2_hp2_x2 = ap2_hp2_x1p; ap2_hp2_x1 = ap2_hp_s1;
ap2_hp2_y2 = ap2_hp2_y1p; ap2_hp2_y1 = ap2_hp;

// Salida: señal con el mismo delay que el crossover LR4
out1 = ap2_lp + ap2_hp;