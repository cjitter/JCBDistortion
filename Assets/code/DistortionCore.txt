// =============================================================================
// DISTORTION CORE BLOCK - Multi-Algorithm Distortion with Tilt & Morphing
// =============================================================================
// Procesamiento de distorsión con 8 algoritmos, Tilt PRE/POST y morphing continuo
// DC mejorado con tanh para asimetría suave
//
// ENTRADAS:
// - in1: Audio L (desde CrossoverStage out1)
// - in2: Audio R (desde CrossoverStage out2)
//
// SALIDAS:
// - out1: L distorsionado con tilt y DC blocker
// - out2: R distorsionado con tilt y DC blocker
// =============================================================================

// -----------------------------------------------------------------------------
// FUNCIONES DE DISTORSIÓN (DEBEN IR PRIMERO!)
// -----------------------------------------------------------------------------

// MODO 0 - Soft Clipping
softclip(inl, inr, dr, dc, cell) {
    lDrivePos = dr * (1.0 + dc);
    lDriveNeg = dr * (1.0 - dc);
    rDrivePos = dr * (1.0 + dc);
    rDriveNeg = dr * (1.0 - dc);

    lNorm = (inl >= 0 ? inl * lDrivePos : inl * lDriveNeg) / cell;
    rNorm = (inr >= 0 ? inr * rDrivePos : inr * rDriveNeg) / cell;

    lCubic = lNorm - (lNorm * lNorm * lNorm) / 3;
    rCubic = rNorm - (rNorm * rNorm * rNorm) / 3;

    lLimited = sign(lNorm) * (2.0 / 3.0);
    rLimited = sign(rNorm) * (2.0 / 3.0);

    lOut = (abs(lNorm) <= 1) ? lCubic : lLimited;
    rOut = (abs(rNorm) <= 1) ? rCubic : rLimited;

    return lOut * cell, rOut * cell;
}

// MODO 1 - Sigmoid
sigmoid(inl, inr, dr, dc, cell) {
    lDrivePos = dr * (1.0 + dc);
    lDriveNeg = dr * (1.0 - dc);
    rDrivePos = dr * (1.0 + dc);
    rDriveNeg = dr * (1.0 - dc);

    lAdj = inl >= 0 ? inl * lDrivePos : inl * lDriveNeg;
    rAdj = inr >= 0 ? inr * rDrivePos : inr * rDriveNeg;

    factor = -1;
    l = (2 * (1 / (1 + exp(factor * lAdj)))) - 1;
    r = (2 * (1 / (1 + exp(factor * rAdj)))) - 1;

    lOut = clip(l * cell, -cell, cell);
    rOut = clip(r * cell, -cell, cell);

    return lOut, rOut;
}

// MODO 2 - Rectificador Full Wave
rectF(inl, inr, dr, dc, cell) {
    lDrivePos = dr * (1.0 + dc);
    lDriveNeg = dr * (1.0 - dc);
    rDrivePos = dr * (1.0 + dc);
    rDriveNeg = dr * (1.0 - dc);

    lAdj = inl >= 0 ? inl * lDrivePos : inl * lDriveNeg;
    rAdj = inr >= 0 ? inr * rDrivePos : inr * rDriveNeg;

    l = sign(lAdj) * abs(lAdj) * 0.707;
    r = sign(rAdj) * abs(rAdj) * 0.707;

    lOut = clip(l, -cell, cell);
    rOut = clip(r, -cell, cell);
    return lOut, rOut;
}

// MODO 3 - Fuzz Exponencial
fuzzExp1(inl, inr, dr, dc, cell) {
    lDrivePos = dr * (1.0 + dc);
    lDriveNeg = dr * (1.0 - dc);
    rDrivePos = dr * (1.0 + dc);
    rDriveNeg = dr * (1.0 - dc);

    lAdj = inl >= 0 ? inl * lDrivePos : inl * lDriveNeg;
    rAdj = inr >= 0 ? inr * rDrivePos : inr * rDriveNeg;

    signl = sign(lAdj);
    signr = sign(rAdj);

    l = signl * (1 - exp(-abs(lAdj)));
    r = signr * (1 - exp(-abs(rAdj)));

    lOut = clip(l, -cell, cell);
    rOut = clip(r, -cell, cell);
    return lOut, rOut;
}

// MODO 4 - Tangente Hiperbólica
tangenteHiperbolica(inl, inr, dr, dc, cell) {
    lDrivePos = dr * (1.0 + dc);
    lDriveNeg = dr * (1.0 - dc);
    rDrivePos = dr * (1.0 + dc);
    rDriveNeg = dr * (1.0 - dc);

    l = inl >= 0 ? clip(inl * lDrivePos, -cell, cell)
                 : clip(inl * lDriveNeg, -cell, cell);

    r = inr >= 0 ? clip(inr * rDrivePos, -cell, cell)
                 : clip(inr * rDriveNeg, -cell, cell);

    lOut = tanh(l) / tanh(dr);
    rOut = tanh(r) / tanh(dr);
    return lOut, rOut;
}

// MODO 5 - Rectificador Half Wave
rectH(inl, inr, dr, dc, cell) {
    lDrivePos = dr * (1.0 + dc);
    rDrivePos = dr * (1.0 + dc);

    lPositive = max(inl * lDrivePos, 0);
    rPositive = max(inr * rDrivePos, 0);

    l = clip(lPositive * 0.5, -cell, cell);
    r = clip(rPositive * 0.5, -cell, cell);
    return l, r;
}

// MODO 6 - Arctangente
arctangent(inl, inr, dr, dc, cell) {
    lDrivePos = dr * (1.0 + dc);
    lDriveNeg = dr * (1.0 - dc);
    rDrivePos = dr * (1.0 + dc);
    rDriveNeg = dr * (1.0 - dc);

    lAdj = inl >= 0 ? inl * lDrivePos : inl * lDriveNeg;
    rAdj = inr >= 0 ? inr * rDrivePos : inr * rDriveNeg;

    l = (2 / pi) * atan(lAdj * 2);
    r = (2 / pi) * atan(rAdj * 2);

    lOut = l * cell;
    rOut = r * cell;
    return lOut, rOut;
}

// MODO 7 - Hard Clip
hardClip(inl, inr, dr, dc, cell) {
    lDrivePos = dr * (1.0 + dc);
    lDriveNeg = dr * (1.0 - dc);
    rDrivePos = dr * (1.0 + dc);
    rDriveNeg = dr * (1.0 - dc);

    lDriven = inl >= 0 ? inl * lDrivePos : inl * lDriveNeg;
    rDriven = inr >= 0 ? inr * rDrivePos : inr * rDriveNeg;

    l = (lDriven > cell) ? cell : ((lDriven < -cell) ? -cell : lDriven);
    r = (rDriven > cell) ? cell : ((rDriven < -cell) ? -cell : rDriven);

    return l, r;
}

// -----------------------------------------------------------------------------
// PARÁMETROS
// -----------------------------------------------------------------------------
Param b_DRIVE(1, min=1, default=1, max=50);
Param c_DC(0, min=0, default=0, max=1);         // DC offset - añade armónicos pares
Param d_MODE(1, min=0, default=0, max=7);       // Continuo 0-7 (8 algoritmos)
Param e_CEILING(0, min=-20, default=0, max=6);
Param i_TILT(0, min=-6, default=0, max=6);      // Tilt filter (dB)
Param p_TILTPOS(0, min=0, default=0, max=1);    // 0=Pre, 1=Post
Param p_DISTON(1, min=0, default=1, max=1);     // Distortion enable

// -----------------------------------------------------------------------------
// HISTORIALES
// -----------------------------------------------------------------------------
History hDrive(0);
History hDc(0);
History hMode(0);
History hTilt(0);
History hTiltPos(0);
History hDistOn(1);

// Historiales para filtros Tilt RBJ - Ruta PRE
History tiltLsL1(0), tiltLsL2(0), tiltLsL3(0), tiltLsL4(0);
History tiltLsR1(0), tiltLsR2(0), tiltLsR3(0), tiltLsR4(0);
History tiltHsL1(0), tiltHsL2(0), tiltHsL3(0), tiltHsL4(0);
History tiltHsR1(0), tiltHsR2(0), tiltHsR3(0), tiltHsR4(0);

// Historiales para filtros Tilt RBJ - Ruta POST
History postTiltLsL1(0), postTiltLsL2(0), postTiltLsL3(0), postTiltLsL4(0);
History postTiltLsR1(0), postTiltLsR2(0), postTiltLsR3(0), postTiltLsR4(0);
History postTiltHsL1(0), postTiltHsL2(0), postTiltHsL3(0), postTiltHsL4(0);
History postTiltHsR1(0), postTiltHsR2(0), postTiltHsR3(0), postTiltHsR4(0);

// -----------------------------------------------------------------------------
// CONSTANTES
// -----------------------------------------------------------------------------
smoothFactor = 0.999;
modeSmoothFactor = 0.99;

// =============================================================================
// PROCESAMIENTO
// =============================================================================

// Entradas desde CrossoverStage
preDistInL = in1;
preDistInR = in2;

// Smoothing de parámetros
hDrive = hDrive * smoothFactor + b_DRIVE * (1 - smoothFactor);
drive = hDrive;

hDc = hDc * smoothFactor + c_DC * (1 - smoothFactor);
dc = hDc;

hMode = hMode * modeSmoothFactor + d_MODE * (1 - modeSmoothFactor);
smoothedMode = hMode;

hTilt = hTilt * smoothFactor + i_TILT * (1 - smoothFactor);
tiltDb = hTilt;

hTiltPos = hTiltPos * smoothFactor + p_TILTPOS * (1 - smoothFactor);
wPost = clamp(hTiltPos, 0, 1);
wPre = 1 - wPost;

hDistOn = hDistOn * smoothFactor + p_DISTON * (1 - smoothFactor);
wDist = clamp(hDistOn, 0, 1);
wClean = 1 - wDist;

ceiling = dbtoa(e_CEILING);

// Normalizar DC para asimetría
dcNorm = hDc * 2.0 - 1.0;
dcSkew = tanh(dcNorm * 3.0) * 0.4;

// -----------------------------------------------------------------------------
// CÁLCULO DE COEFICIENTES TILT RBJ
// -----------------------------------------------------------------------------
fc = 1000.0;
omega = (fc * twopi) / samplerate;
sn = sin(omega);
cs = cos(omega);

Gls = -tiltDb;
Ghs = tiltDb;

Als = sqrt(dbtoa(Gls));
Ahs = sqrt(dbtoa(Ghs));

S = 0.5;

alphaLs = 0.5 * sn * sqrt((Als + 1/Als) * (1/S - 1) + 2);
alphaHs = 0.5 * sn * sqrt((Ahs + 1/Ahs) * (1/S - 1) + 2);

sqrtAls = sqrt(Als);
sqrtAhs = sqrt(Ahs);

// Low-Shelf
b0_ls = Als * ((Als + 1) - (Als - 1) * cs + 2 * sqrtAls * alphaLs);
b1_ls = 2*Als * ((Als - 1) - (Als + 1) * cs);
b2_ls = Als * ((Als + 1) - (Als - 1) * cs - 2 * sqrtAls * alphaLs);
a0_ls = (Als + 1) + (Als - 1) * cs + 2 * sqrtAls * alphaLs;
a1_ls = -2 * ((Als - 1) + (Als + 1) * cs);
a2_ls = (Als + 1) + (Als - 1) * cs - 2 * sqrtAls * alphaLs;

inv_a0_ls = 1 / a0_ls;
a0Ls = b0_ls * inv_a0_ls;
a1Ls = b1_ls * inv_a0_ls;
a2Ls = b2_ls * inv_a0_ls;
b1Ls = a1_ls * inv_a0_ls;
b2Ls = a2_ls * inv_a0_ls;

// High-Shelf
b0_hs = Ahs * ((Ahs + 1) + (Ahs - 1) * cs + 2 * sqrtAhs * alphaHs);
b1_hs = -2*Ahs * ((Ahs - 1) + (Ahs + 1) * cs);
b2_hs = Ahs * ((Ahs + 1) + (Ahs - 1) * cs - 2 * sqrtAhs * alphaHs);
a0_hs = (Ahs + 1) - (Ahs - 1) * cs + 2 * sqrtAhs * alphaHs;
a1_hs = 2 * ((Ahs - 1) - (Ahs + 1) * cs);
a2_hs = (Ahs + 1) - (Ahs - 1) * cs - 2 * sqrtAhs * alphaHs;

inv_a0_hs = 1 / a0_hs;
a0Hs = b0_hs * inv_a0_hs;
a1Hs = b1_hs * inv_a0_hs;
a2Hs = b2_hs * inv_a0_hs;
b1Hs = a1_hs * inv_a0_hs;
b2Hs = a2_hs * inv_a0_hs;

// Normalización en el pivote
cosw = cs;
sinw = sn;
cos2 = (cs*cs - sn*sn);
sin2 = (2*sn*cs);

nr_ls = a0Ls + a1Ls*cosw + a2Ls*cos2;
ni_ls = -(a1Ls*sinw + a2Ls*sin2);
dr_ls = 1 + b1Ls*cosw + b2Ls*cos2;
di_ls = -(b1Ls*sinw + b2Ls*sin2);
mag2_ls = (nr_ls*nr_ls + ni_ls*ni_ls) / max(1e-12, (dr_ls*dr_ls + di_ls*di_ls));
mag_ls = sqrt(mag2_ls);

nr_hs = a0Hs + a1Hs*cosw + a2Hs*cos2;
ni_hs = -(a1Hs*sinw + a2Hs*sin2);
dr_hs = 1 + b1Hs*cosw + b2Hs*cos2;
di_hs = -(b1Hs*sinw + b2Hs*sin2);
mag2_hs = (nr_hs*nr_hs + ni_hs*ni_hs) / max(1e-12, (dr_hs*dr_hs + di_hs*di_hs));
mag_hs = sqrt(mag2_hs);

gPivot = 1 / max(1e-9, mag_ls * mag_hs);

// -----------------------------------------------------------------------------
// RUTA A (PRE): Tilt → Distorsión
// -----------------------------------------------------------------------------

// Aplicar Tilt PRE
lLs = a0Ls * preDistInL + a1Ls * fixdenorm(tiltLsL2) + a2Ls * fixdenorm(tiltLsL1)
    - b1Ls * fixdenorm(tiltLsL4) - b2Ls * fixdenorm(tiltLsL3);
tiltLsL1 = tiltLsL2; tiltLsL2 = preDistInL; tiltLsL3 = tiltLsL4; tiltLsL4 = lLs;

rLs = a0Ls * preDistInR + a1Ls * fixdenorm(tiltLsR2) + a2Ls * fixdenorm(tiltLsR1)
    - b1Ls * fixdenorm(tiltLsR4) - b2Ls * fixdenorm(tiltLsR3);
tiltLsR1 = tiltLsR2; tiltLsR2 = preDistInR; tiltLsR3 = tiltLsR4; tiltLsR4 = rLs;

lTiltRaw = a0Hs * lLs + a1Hs * fixdenorm(tiltHsL2) + a2Hs * fixdenorm(tiltHsL1)
         - b1Hs * fixdenorm(tiltHsL4) - b2Hs * fixdenorm(tiltHsL3);
tiltHsL1 = tiltHsL2; tiltHsL2 = lLs; tiltHsL3 = tiltHsL4; tiltHsL4 = lTiltRaw;

rTiltRaw = a0Hs * rLs + a1Hs * fixdenorm(tiltHsR2) + a2Hs * fixdenorm(tiltHsR1)
         - b1Hs * fixdenorm(tiltHsR4) - b2Hs * fixdenorm(tiltHsR3);
tiltHsR1 = tiltHsR2; tiltHsR2 = rLs; tiltHsR3 = tiltHsR4; tiltHsR4 = rTiltRaw;

lTiltPre = lTiltRaw * gPivot;
rTiltPre = rTiltRaw * gPivot;

// Aplicar Distorsión a la señal con Tilt PRE
softL_A, softR_A = softclip(lTiltPre, rTiltPre, drive, dcSkew, ceiling);
sigmL_A, sigmR_A = sigmoid(lTiltPre, rTiltPre, drive, dcSkew, ceiling);
rectL_A, rectR_A = rectF(lTiltPre, rTiltPre, drive, dcSkew, ceiling);
fuzz1L_A, fuzz1R_A = fuzzExp1(lTiltPre, rTiltPre, drive, dcSkew, ceiling);
tanhL_A, tanhR_A = tangenteHiperbolica(lTiltPre, rTiltPre, drive, dcSkew, ceiling);
recthL_A, recthR_A = rectH(lTiltPre, rTiltPre, drive, dcSkew, ceiling);
atanL_A, atanR_A = arctangent(lTiltPre, rTiltPre, drive, dcSkew, ceiling);
hardL_A, hardR_A = hardClip(lTiltPre, rTiltPre, drive, dcSkew, ceiling);

mode = smoothedMode;
w0 = max(0, 1 - abs(mode - 0));
w1 = max(0, 1 - abs(mode - 1));
w2 = max(0, 1 - abs(mode - 2));
w3 = max(0, 1 - abs(mode - 3));
w4 = max(0, 1 - abs(mode - 4));
w5 = max(0, 1 - abs(mode - 5));
w6 = max(0, 1 - abs(mode - 6));
w7 = max(0, 1 - abs(mode - 7));

sumWeights = w0 + w1 + w2 + w3 + w4 + w5 + w6 + w7 + 0.0001;
w0 /= sumWeights; w1 /= sumWeights; w2 /= sumWeights; w3 /= sumWeights;
w4 /= sumWeights; w5 /= sumWeights; w6 /= sumWeights; w7 /= sumWeights;

distL_A = softL_A * w0 + sigmL_A * w1 + rectL_A * w2 + fuzz1L_A * w3 +
          tanhL_A * w4 + recthL_A * w5 + atanL_A * w6 + hardL_A * w7;
distR_A = softR_A * w0 + sigmR_A * w1 + rectR_A * w2 + fuzz1R_A * w3 +
          tanhR_A * w4 + recthR_A * w5 + atanR_A * w6 + hardR_A * w7;

preOutL = dcblock(distL_A);
preOutR = dcblock(distR_A);

// -----------------------------------------------------------------------------
// RUTA B (POST): Distorsión → Tilt
// -----------------------------------------------------------------------------

// Aplicar Distorsión SIN Tilt
softL_B, softR_B = softclip(preDistInL, preDistInR, drive, dcSkew, ceiling);
sigmL_B, sigmR_B = sigmoid(preDistInL, preDistInR, drive, dcSkew, ceiling);
rectL_B, rectR_B = rectF(preDistInL, preDistInR, drive, dcSkew, ceiling);
fuzz1L_B, fuzz1R_B = fuzzExp1(preDistInL, preDistInR, drive, dcSkew, ceiling);
tanhL_B, tanhR_B = tangenteHiperbolica(preDistInL, preDistInR, drive, dcSkew, ceiling);
recthL_B, recthR_B = rectH(preDistInL, preDistInR, drive, dcSkew, ceiling);
atanL_B, atanR_B = arctangent(preDistInL, preDistInR, drive, dcSkew, ceiling);
hardL_B, hardR_B = hardClip(preDistInL, preDistInR, drive, dcSkew, ceiling);

distL_B = softL_B * w0 + sigmL_B * w1 + rectL_B * w2 + fuzz1L_B * w3 +
          tanhL_B * w4 + recthL_B * w5 + atanL_B * w6 + hardL_B * w7;
distR_B = softR_B * w0 + sigmR_B * w1 + rectR_B * w2 + fuzz1R_B * w3 +
          tanhR_B * w4 + recthR_B * w5 + atanR_B * w6 + hardR_B * w7;

postInL = dcblock(distL_B);
postInR = dcblock(distR_B);

// Aplicar Tilt POST a la señal distorsionada
postLsL = a0Ls * postInL + a1Ls * fixdenorm(postTiltLsL2) + a2Ls * fixdenorm(postTiltLsL1)
        - b1Ls * fixdenorm(postTiltLsL4) - b2Ls * fixdenorm(postTiltLsL3);
postTiltLsL1 = postTiltLsL2; postTiltLsL2 = postInL; 
postTiltLsL3 = postTiltLsL4; postTiltLsL4 = postLsL;

postLsR = a0Ls * postInR + a1Ls * fixdenorm(postTiltLsR2) + a2Ls * fixdenorm(postTiltLsR1)
        - b1Ls * fixdenorm(postTiltLsR4) - b2Ls * fixdenorm(postTiltLsR3);
postTiltLsR1 = postTiltLsR2; postTiltLsR2 = postInR;
postTiltLsR3 = postTiltLsR4; postTiltLsR4 = postLsR;

postTiltRawL = a0Hs * postLsL + a1Hs * fixdenorm(postTiltHsL2) + a2Hs * fixdenorm(postTiltHsL1)
             - b1Hs * fixdenorm(postTiltHsL4) - b2Hs * fixdenorm(postTiltHsL3);
postTiltHsL1 = postTiltHsL2; postTiltHsL2 = postLsL;
postTiltHsL3 = postTiltHsL4; postTiltHsL4 = postTiltRawL;

postTiltRawR = a0Hs * postLsR + a1Hs * fixdenorm(postTiltHsR2) + a2Hs * fixdenorm(postTiltHsR1)
             - b1Hs * fixdenorm(postTiltHsR4) - b2Hs * fixdenorm(postTiltHsR3);
postTiltHsR1 = postTiltHsR2; postTiltHsR2 = postLsR;
postTiltHsR3 = postTiltHsR4; postTiltHsR4 = postTiltRawR;

postTiltL = postTiltRawL * gPivot;
postTiltR = postTiltRawR * gPivot;

// -----------------------------------------------------------------------------
// MORPH PRE/POST Y BYPASS DISTORSIÓN
// -----------------------------------------------------------------------------

// Morphing entre PRE y POST
distMorphL = mix(preOutL, postTiltL, wPost);
distMorphR = mix(preOutR, postTiltR, wPost);

// Clean = solo Tilt sin distorsión
cleanL = lTiltPre;
cleanR = rTiltPre;

// Salida final: mezclar entre clean y distorsionado
processedL = mix(cleanL, distMorphL, wDist);
processedR = mix(cleanR, distMorphR, wDist);

// -----------------------------------------------------------------------------
// SALIDAS
// -----------------------------------------------------------------------------
out1 = processedL;  // L procesado completo → EffectsChain in1
out2 = processedR;  // R procesado completo → EffectsChain in2
